import define1 from "./ref_2.js";
import define2 from "./ref_5.js";
import define3 from "./ref_1.js";

export default function define(runtime, observer) {
  const main = runtime.module();
  const fileAttachments = new Map([
    ["download_korea.csv", new URL("./files/download_korea", import.meta.url)],
    ["download_japan.csv", new URL("./files/download_japan", import.meta.url)],
    ["download_china.csv", new URL("./files/download_china", import.meta.url)],
    ["usa.csv", new URL("./files/usa", import.meta.url)],
    ["taiwan.csv", new URL("./files/taiwan", import.meta.url)],
    ["japan.csv", new URL("./files/japan", import.meta.url)],
    ["korea.csv", new URL("./files/korea", import.meta.url)],
    ["fina_data.json", new URL("./files/fina_data", import.meta.url)],
    ["World-wide game type IOS income (1)-1.mp4", new URL("./files/World-wide", import.meta.url)],
    ["performance chart.csv", new URL("./files/performance", import.meta.url)],
    ["download_usa.csv", new URL("./files/download_usa", import.meta.url)],
    ["download_taiwan.csv", new URL("./files/download_taiwan", import.meta.url)],
    ["china@1.csv", new URL("./files/china@1", import.meta.url)]]);
  main.builtin("FileAttachment", runtime.fileAttachments(name => fileAttachments.get(name)));
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`# ReadyPlayerOne --Question 2`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`
*<span style="font-size: 12pt"> Attention: If you experience scaling issue for our visualizations, please narrow your viewing window. Enjoy ! </span>* ðŸ˜‰ 
`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`## Q2: Which game type generated maximum revenues in 2018 and 2019, and which is the most promising type in the future? `
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`In this section, we will mostly focus on analysing aspects associated with the game types. We are going to implement the visualization as follows:
- (a). Trend of total IOS income generated by each game type overtime
- (b). Monthly IOS income change based on game types among five regions
- (c). Game types allocation and their earning power in each region
- (d). Game types earning power proportion in each region overtime
- (e). IOS income and downloads trend for each game in each region

`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`## (a) Trend of Total IOS Income Generated by Each Game Type Overtime`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`### ðŸ”¥ Performance chart for growth of game type globally`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md` This section aims to investigate the revenue for each game category  overtime and to show which category is more likely to be profitable to invest in the future. PerformanceChart depicts the evolution of time-series categorical data by segmenting categories into two sections based on their performance. It is beneficial for tracking overall and individual changes over time. The chart sorts categories by the change from the previous period, then segments them into rising and falling sections. Dots in each section are shaded using individual color scheme to emphasize the visual aspect of interpretation.

The chart below visualizes the IOS income of each game type across the five regions from Jan-2018 to Dec-2019.`
    )
  });
  main.variable(observer("viewof options_3")).define("viewof options_3", ["form", "html"], function (form, html) {
    return (
      form(html`<form style="font-size: 11pt">
Dot Shape:
<label for="circle"><input name="shape" id="circle" type="radio" value="circle" group="s" checked>Circle</label>
<label for="square"><input name="shape" id="square" type="radio" value="square" group="s">Square</label>
<span style="border-left: 2px solid #ddd; padding-left: 5px">
Color:
<label for="growth"><input name="number" id="growth" type="radio" value="growth" group="n" checked>Growth</label>
<label for="rate"><input name="number" id="rate" type="radio" value="rate" group="n">Growth Rate</label>
</span>
</span>
<span style="border-left: 2px solid #ddd; padding-left: 5px">
<input type=checkbox name=isounc checked>Isolate Unchanged</input>
</span>

<br>
Color Scheme:
<select name="scheme">
<option value="rdylbu">Rd-Yl-Bu</option>
<option value="rdpubu">Rd-Pu-Bu</option>
<option value="rdylgn">Rd-Yl-Gn</option>
<option value="rdgn">Rd-Gn</option>
<option value="orbu">Or-Bu</option>
</select>
<span style="border-left: 2px solid #ddd; padding-left: 5px">
Theme:
<select name="theme">
<option value="dark">Dark</option>
<option value="light" selected>Light</option>
</select>
</span>

<br>
<span id="time"></span>
<input name="year" type="range" min="0" max="1" value="0" style="width: 100px; margin-left: 5px">

<select name="frame">
<option value="1">1 Years</option>
<option value="2">2 Years</option>

</select>
<div style="font-size:10pt;font-style:italic">Hover over chart/legend to highlight a specific category/range. Click on a dot/range to lock or switch the highlight. Click again or click on empty space to cancel the highlight. Category and range can be highlighted at the same time for cross-referencing.</div>
</form>`)
    )
  });
  main.variable(observer("options_3")).define("options_3", ["Generators", "viewof options_3"], (G, _) => G.input(_));
  main.variable(observer("chart")).define("chart", ["options_3", "d3", "width", "getPalettes", "PerformanceChart", "performance_chart"], function* (options_3, d3, width, getPalettes, PerformanceChart, performance_chart) {
    const isDark = options_3.theme === "dark";
    const svg = d3
      .create("svg")
      .style("cursor", "default")
      .style("background", isDark ? "black" : "white")
      .attr("viewBox", [0, 0, width, 500]);

    yield svg.node();

    const { pp, np } = getPalettes(options_3.scheme),
      tc = isDark ? "white" : "black",
      s = +options_3.year * 12 + 1,
      e = s + +options_3.frame * 12;

    const pchart = new PerformanceChart(svg)
      .size([700, 700])
      .data(performance_chart.slice(s, e))
      .tick({
        name: "Month",
        interval: 12,
        extractor: d => {
          const ss = d.split(" ");
          return ss.length === 2 ? ss[1] : d;
        },
        color: tc
      })
      .options({
        number: options_3.number,
        shape: options_3.shape,
        posPalette: pp,
        negPalette: np,
        isolateUnchanged: options_3.isounc,
        showSlider: true
      })
      .color({
        legend: tc,
        hover: isDark ? "white" : "#999",
        highlighter: isDark ? "#999" : "#eee"
      })
      .tooltip({ boxOpacity: isDark ? 0.9 : 0.8 })
      .render();

    return svg.node();
  }
  );
  main.variable(observer()).define(["md"], function (md) {
    return (
      md` According to the performance chart above, we can observe an overall trend of each game type, in terms of its growth and growth rate. Each dot representing a single game type, and different colors are set based on their growth as well as growth rate (can be chosen freely) of IOS income. This plot is for interactive purpose and you can extract a lot of information of the IOS income growth trend for different game types. For example, we can see that the IOS incomes of battle royale game fluctuated during the time period, and one of its significant growth in IOS income was from 2018.01 to 2018.02, with overall growth rate of over 168%. 
`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
          md`## (b) Monthly IOS income change based on game types among five regions`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`The performance chart offer us an inerative way to explore earning power change in terms of different game type, however, to be more specific, we established the bar chart race animation to give an overview of IOS income between each game type from the year 2018 to 2019 among five regions.

Based on the race animation, we are able to explore some features among game types. For example, the Turn-based Card RPG had the greatest income of all time, and its earning power also stayed steady across time, while SLG and Battle royale game had larger future potentials due to their high increase paces.
`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`### ðŸ”¥ Bar Chart Race animation for IOS Income Based on Game Type across Time`
    )
  });
  main.variable(observer("viewof currentTime")).define("viewof currentTime", ["videoControls1", "video"], function (videoControls1, video) {
    return (
      videoControls1(video)
    )
  });
  main.variable(observer("currentTime")).define("currentTime", ["Generators", "viewof currentTime"], (G, _) => G.input(_));
  main.variable(observer("video")).define("video", ["md", "videoUrl"], function (md, videoUrl) {
    return (
      md`<video src=${videoUrl} height=480 controls />`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`## (c) Game Types Allocation and Their Earning Power in Each Region
`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`In this section, we aims to evaluate the most popular game types based on their IOS income in each game market, providing us strategic references for the later game development and publishment. Therefore, to get an overview of the proportion of each game type in each market, a heat-map was created.`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`### ðŸ”¥ Heat-map for Game Types`
    )
  });
  main.variable(observer("heatmap")).define("heatmap", ["partition", "region_wise", "d3", "color", "format", "height_2", "width"], function (partition, region_wise, d3, color, format, height_2, width) {
    const root = partition(region_wise);
    let focus = root;

    const svg = d3
      .create("svg")
      .attr("viewBox", [0, 0, 1400, 1200])
      .style("font", "14px sans-serif");

    const cell = svg
      .selectAll("g")
      .data(root.descendants())
      .join("g")
      .attr("transform", d => `translate(${d.y0},${d.x0})`);

    const rect = cell
      .append("rect")
      .attr("width", d => d.y1 - d.y0 - 1)
      .attr("height", d => rectHeight(d))
      .attr("fill-opacity", 0.6)
      .attr("fill", d => {
        if (!d.depth) return "#ccc";
        while (d.depth > 1) d = d.parent;
        return color(d.data.name);
      })
      .style("cursor", "pointer")
      .on("click", clicked);

    const text = cell
      .append("text")
      .style("user-select", "none")
      .attr("pointer-events", "none")
      .attr("x", 4)
      .attr("y", 13)
      .attr("fill-opacity", d => +labelVisible(d));

    text.append("tspan").text(d => d.data.name);

    const tspan = text
      .append("tspan")
      .attr("fill-opacity", d => labelVisible(d) * 0.7)
      .text(d => ` ${format(d.value)}`);

    cell.append("title").text(
      d =>
        `${d
          .ancestors()
          .map(d => d.data.name)
          .reverse()
          .join("/")}\n${format(d.value)}`
    );

    function clicked(event, p) {
      focus = focus === p ? (p = p.parent) : p;

      root.each(
        d =>
        (d.target = {
          x0: ((d.x0 - p.x0) / (p.x1 - p.x0)) * height_2,
          x1: ((d.x1 - p.x0) / (p.x1 - p.x0)) * height_2,
          y0: d.y0 - p.y0,
          y1: d.y1 - p.y0
        })
      );

      const t = cell
        .transition()
        .duration(750)
        .attr("transform", d => `translate(${d.target.y0},${d.target.x0})`);

      rect.transition(t).attr("height", d => rectHeight(d.target));
      text.transition(t).attr("fill-opacity", d => +labelVisible(d.target));
      tspan.transition(t).attr("fill-opacity", d => labelVisible(d.target) * 0.7);
    }

    function rectHeight(d) {
      return d.x1 - d.x0 - Math.min(1, (d.x1 - d.x0) / 2);
    }

    function labelVisible(d) {
      return d.y1 <= width && d.y0 >= 0 && d.x1 - d.x0 > 16;
    }

    return svg.node();
  }
  );
  main.variable(observer()).define(["md"], function (md) {
    return (
      md` The above heat map depicts the total IOS income for game type across five different markets. We first split the map into five different blocks, which represent five game markets of mainland China, USA, Japan, Taiwan, and South Korea, respectively. The size of block refers to the IOS income, with larger size representing higher IOS income. As we dive deeper, for each block of game market, every game type is listed and ranked according to their income. Furthermore, individual games that constitute each game type are also showed in the last chunk in case we want to investigate further. 

Generally speaking, role playing games are favoured in asian markets. Action real-time MMORPG, turn-based MMORPG are the two important game types in both Chinese and Taiwanese mobile game market. In contrast, Japan seems to be more in favor of turned-based card RPG games. Similarly, action real-time MMORPG and turned-based RPG games play leading roles in Korean market. On the other hand, the allocation of game types are more dispersive. In this case, slot machine gambling, traditional anipop and SLG games are top three game types in American market. The income difference among these three games are not quite subtle compared to the situations in other regions.
`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`## (d)  Game Types Revenue Proportion in Each Region Overtime`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`To further investigate the revenue variation of each game types during the time span in five regions, an interactive stack graph of game types based on monthly IOS income was created. `
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`### ðŸ”¥ Game Types Revenue Stack Plot `
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`In the interactive stack plot, the monthly IOS income proportion of each game type in each region was presented, with each color representing one mobile game market (Yellow-Mainland, China; Orange-Japan; Blue-Korea; Purple-Taiwan; Green-USA.). The bolder the game type's name is, the more important the game type is for a certain mobile game market.

You can also click the button below to choose which mobile game market you would like to inspect. You can also either click elements or type queries to explore. The search box supports regular expression. For example, the query "RPG" finds all game types related with "RPG". `
    )
  });
  main.variable(observer("viewof view2")).define("viewof view2", ["embed"], function (embed) {
    return (
      embed({
        width: 800,
        height: 700,
        padding: 5,

        signals: [
          {
            name: "Region",
            value: "all",
            bind: {
              input: "radio",
              options: ["China", "Japan", "Korea", "Taiwan", "USA", "all"]
            }
          },
          {
            name: "query",
            value: "",
            on: [
              { events: "area:click!", update: "datum.game_type" },
              { events: "dblclick!", update: "''" }
            ],
            bind: { input: "text", placeholder: "search", autocomplete: "off" }
          }
        ],

        data: [
          {
            name: "game_types",
            url:
              "https://gist.githubusercontent.com/LunaChang0808/5a4970bc5fffe3ea5df5a9c888208b9b/raw/0066835bd81a0697e02167b39e2ce160be9a7d9d/p2.a_game_type_2.json",
            format: {
              type: "json",
              parse: { Month: "date:'%Y/%m'" }
            },
            transform: [
              {
                type: "filter",
                expr:
                  "(Region === 'all' || datum.Region === Region) && (!query || test(regexp(query,'i'), datum.game_type))"
              },
              {
                type: "stack",
                field: "perc",
                groupby: ["Month"],
                sort: {
                  field: ["game_type", "Region"],
                  order: ["descending", "descending"]
                }
              }
            ]
          },
          {
            name: "series",
            source: "game_types",
            transform: [
              {
                type: "aggregate",
                groupby: ["game_type", "Region"],
                fields: ["perc", "perc"],
                ops: ["sum", "argmax"],
                as: ["sum", "argmax"]
              }
            ]
          }
        ],

        scales: [
          {
            name: "x",
            type: "linear",
            range: "width",
            zero: false,
            round: true,
            domain: { data: "game_types", field: "Month" }
          },
          {
            name: "y",
            type: "linear",
            range: "height",
            round: true,
            zero: true,
            domain: { data: "game_types", field: "y1" }
          },
          {
            name: "color",
            type: "ordinal",
            domain: ["China", "Japan", "Korea", "Taiwan", "USA"],
            range: ["#ffcb69", "#ff7f51", "#5aa9e6", "#7161ef", "#8ac926"]
          },
          {
            name: "alpha",
            type: "linear",
            zero: true,
            domain: { data: "series", field: "sum" },
            range: [0.4, 0.8]
          },
          {
            name: "font",
            type: "sqrt",
            range: [0, 20],
            round: true,
            zero: true,
            domain: { data: "series", field: "argmax.perc" }
          },
          {
            name: "opacity",
            type: "quantile",
            range: [0, 0, 0, 0, 0, 0.1, 0.2, 0.4, 0.7, 1.0],
            domain: { data: "series", field: "argmax.perc" }
          },
          {
            name: "align",
            type: "quantize",
            range: ["left", "center", "right"],
            zero: false,
            domain: [1730, 2130]
          },
          {
            name: "offset",
            type: "quantize",
            range: [6, 0, -6],
            zero: false,
            domain: [1730, 2130]
          }
        ],

        axes: [
          {
            orient: "bottom",
            scale: "x",
            formatType: "time",
            format: "%y/%m",
            tickCount: 20
          },
          {
            orient: "right",
            scale: "y",
            format: "%",
            grid: true,
            domain: false,
            tickSize: 12,
            encode: {
              grid: { enter: { stroke: { value: "#ccc" } } },
              ticks: { enter: { stroke: { value: "#ccc" } } }
            }
          }
        ],

        marks: [
          {
            type: "group",
            from: {
              data: "series",
              facet: {
                name: "facet",
                data: "game_types",
                groupby: ["game_type", "Region"]
              }
            },

            marks: [
              {
                type: "area",
                from: { data: "facet" },
                encode: {
                  update: {
                    x: { scale: "x", field: "Month" },
                    y: { scale: "y", field: "y0" },
                    y2: { scale: "y", field: "y1" },
                    fill: { scale: "color", field: "Region" },
                    fillOpacity: { scale: "alpha", field: { parent: "sum" } }
                  },
                  hover: {
                    fillOpacity: { value: 0.2 }
                  }
                }
              }
            ]
          },
          {
            type: "text",
            from: { data: "series" },
            interactive: false,
            encode: {
              update: {
                x: { scale: "x", field: "argmax.Month" },
                dx: { scale: "offset", field: "argmax.Month" },
                y: {
                  signal: "scale('y', 0.5 * (datum.argmax.y0 + datum.argmax.y1))"
                },
                fill: { value: "#000" },
                fillOpacity: { scale: "opacity", field: "argmax.perc" },
                fontSize: { scale: "font", field: "argmax.perc", offset: 5 },
                text: { field: "game_type" },
                align: { scale: "align", field: "argmax.Month" },
                baseline: { value: "middle" }
              }
            }
          }
        ]
      })
    )
  });
  main.variable(observer("view2")).define("view2", ["Generators", "viewof view2"], (G, _) => G.input(_));
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`
There are a lot of information you can extract from this graph, including overall market share for each region, market share of each game type in each region overtime, general game types allocation in each region, the revenue proportion for aggregated game types, etc.

From the overall color distribution, we can see large areas of yellow, orange and green, indicating the predominance of mobile game market in Mainland (China), Japan and USA. We can also reach the similar conclusion as specified in the interpreation of heatmap. On top of that, if you click each color area on the plot, you can dive down to check the monthly revenue proportion trend of each game type. For example, if you click "Turned-based MMORPG" in yellow, you could see that it is extremely welcomed in China, while for other regions, this type of game might not generate too much revenue. Moreover, we can search the monthly revenue proportion of RPG related games accounted for around 30% IOS income within five regions over two-year period. `
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`## (e) IOS Income and Downloads Trend for Each Game in Each Region`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`
Last but not least, the IOS income and downloads fluctuation during 2018 and 2019 for each game in each region was illustrated in the following heatmap table and barplot. 

The goal is to get an idea of revenue change for each game that was listed top 100 in each region in 2018 and 2019. As time changes, some of the game might drop out of the top 100 popular game in a certain region or some of the game might be unknown in the beginning and somehow it catches mobile gamers' eyes and become popular. Therefore, with the barplots we can get detailed information of games remained popular during this period of time, as well as the games that were not on the list in the early period, and the later on gained popularity, and the games that were welcomed at first and their popularity faded away with time going on, etc. 
`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`### ðŸ”¥ Dashboard of IOS Income for Each Game in Each Region`
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`
*<span style="font-size: 11pt">Below is a functional IOS income of each game dashboard incorporated with a bar chart. The games in the table is listed according to their gross IOS income or downloads during two years so that you can start to investigate the most lucrative games in each region and their earning power trend within the time period. </span>*

*<span style="font-size: 11pt"> Before you keep reading, play with the dashboard to see what the table can do and how it interacts with other elements.</span>*

*<span style="font-size: 11pt">Click a cell to lock the focus, to release just click the same cell again or press Esc. It is very useful in locating a focused row after the table has been sorted, or if you need to keep the highlight while moving the mouse to another part of the dashboard. In addition, if you hover your mouse on each bar of the barplot, the corresponding IOS income or download amount will appear so that you could have a detailed idea of what the number is.</span>*`
    )
  });
  main.variable(observer("viewof options")).define("viewof options", ["form", "html"], function (form, html) {
    return (
      form(html`<form style="font-size: 11pt">
Income: 
</select>
<label for="china"><input name="dataset" id="china" type="radio" value="china" group="d">China</label>
</select>
<label for="japan"><input name="dataset" id="japan" type="radio" value="japan" group="d">Japan</label>
</select>
<label for="korea"><input name="dataset" id="korea" type="radio" value="korea" group="d">Korea</label>
</select>
<label for="taiwan"><input name="dataset" id="taiwan" type="radio" value="taiwan" group="d">Taiwan</label>
</select>
<label for="usa"><input name="dataset" id="usa" type="radio" value="usa" group="d">USA</label>
<br>
Sticky Columns: <input name="cols" type="range" min="0" max="3" value="1" style="width: 80px">
<span style="margin-left: 10px">Rows: <input name="rows" type="range" min="0" max="4" value="1" style="width: 50px"></span>
<span style="margin-left: 10px">
<input type="checkbox" name="border">Border</input>
<input type="checkbox" name="heatmap" checked>Heatmap</input>
</span><br>
Font Size: <input name="fontsize" type="range" min="8" max="14" value="11" style="width: 20px">
Highlight: 
<input name="highlight" id="none" type="radio" value="none" group="h"><label for="none">None</label>
<input name="highlight" id="cross" type="radio" value="cross" group="h" checked><label for="cross">Cross</label>
<input name="highlight" id="cell" type="radio" value="cell" group="h"><label for="cell">Cell</label>
<br>
Header: <input type="color" name="header" value="#dddddd" style="height:16px">
<span style="margin-left: 10px">Fixed Cell: <input type="color" name="fixed" value="#eeeeee" style="height:16px"></span>
<span style="margin-left: 10px">Cell: <input type="color" name="cell" value="#ffffff" style="height:16px"></span>
<span style="margin-left: 10px">Border: <input type="color" name="borderColor" value="#aaaaaa" style="height:16px"></span>
<span style="margin-left: 10px">Text: <input type="color" name="text" value="#000000" style="height:16px"></span>
<span style="margin-left: 10px">Highlight: <input type="color" name="highlightColor" value="#fff3b0" style="height:16px"></span>
</form>`)
    )
  });
  main.variable(observer("options")).define("options", ["Generators", "viewof options"], (G, _) => G.input(_));
  main.variable(observer("dashboard")).define("dashboard", ["d3", "options", "SVGTable", "ios_income", "miniChart"], function* (d3, options, SVGTable, ios_income, miniChart) {
    const svg = d3
      .create("svg")
      .attr("font-size", `${options.fontsize}pt`)
      .attr("viewBox", [0, 0, 975, 750]);

    yield svg.node(); // for autoSizeCell

    const table = new SVGTable(svg)
      .extent([[25, 25], [950, 400]])
      .fixedRows(+options.rows)
      .fixedColumns(+options.cols)
      .rowsPerPage(100)
      .autoSizeCell(true)
      .defaultColumnWidth(options.dataset === "china" ? 20 : 20)
      .defaultNumberFormat(options.dataset === "china" ? "$,.0f" : "$,.0f")
      .style({
        border: options.border,
        borderColor: options.borderColor,
        textColor: options.text,
        highlight: options.highlight,
        background: options.cell,
        headerBackground: options.header,
        fixedBackground: options.fixed,
        highlightBackground: options.highlightColor
      })
      .heatmap(options.heatmap)
      .heatmapPalette(d3.interpolateReds)
      .data(ios_income)
      .onhighlight((e, c) => {
        chart(c);
      });

    table.render();

    const chart = miniChart(svg, 50, 450, 920, 250);
    return svg.node();
  }
  );
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`For instance, we can see that the most lucrative game in Mainland, China is "Honour of Kings". From its barplot, it seems that this game remain general popularity over two years, even though with rather lower monthly revenue around April to June and September each year. On the contrary, "Game For Peace" was listed the 4th most profitale games, and it was not on the popular list until May 2019. After gaining the popularity, it showed a quite  competitive earning power. `
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`### ðŸ”¥  Dashboard of IOS Downloads for Each Game in Each Region`
    )
  });
  main.variable(observer("viewof options_2")).define("viewof options_2", ["form", "html"], function (form, html) {
    return (
      form(html`<form style="font-size: 11pt">
Downloads: 
</select>
<label for="china"><input name="dataset" id="china" type="radio" value="china" group="d">China</label>
</select>
<label for="japan"><input name="dataset" id="japan" type="radio" value="japan" group="d">Japan</label>
</select>
<label for="korea"><input name="dataset" id="korea" type="radio" value="korea" group="d">Korea</label>
</select>
<label for="taiwan"><input name="dataset" id="taiwan" type="radio" value="taiwan" group="d">Taiwan</label>
</select>
<label for="usa"><input name="dataset" id="usa" type="radio" value="usa" group="d">USA</label>
<br>
Sticky Columns: <input name="cols" type="range" min="0" max="3" value="1" style="width: 50px">
<span style="margin-left: 10px">Rows: <input name="rows" type="range" min="0" max="4" value="1" style="width: 50px"></span>
<span style="margin-left: 10px">
<input type="checkbox" name="border">Border</input>
<input type="checkbox" name="heatmap" checked>Heatmap</input>
</span><br>
Font Size: <input name="fontsize" type="range" min="8" max="14" value="11" style="width: 50px">
Highlight: 
<input name="highlight" id="none" type="radio" value="none" group="h"><label for="none">None</label>
<input name="highlight" id="cross" type="radio" value="cross" group="h" checked><label for="cross">Cross</label>
<input name="highlight" id="cell" type="radio" value="cell" group="h"><label for="cell">Cell</label>
<br>
Header: <input type="color" name="header" value="#dddddd" style="height:16px">
<span style="margin-left: 10px">Fixed Cell: <input type="color" name="fixed" value="#eeeeee" style="height:16px"></span>
<span style="margin-left: 10px">Cell: <input type="color" name="cell" value="#ffffff" style="height:16px"></span>
<span style="margin-left: 10px">Border: <input type="color" name="borderColor" value="#aaaaaa" style="height:16px"></span>
<span style="margin-left: 10px">Text: <input type="color" name="text" value="#000000" style="height:16px"></span>
<span style="margin-left: 10px">Highlight: <input type="color" name="highlightColor" value="#fff3b0" style="height:16px"></span>
</form>`)
    )
  });
  main.variable(observer("options_2")).define("options_2", ["Generators", "viewof options_2"], (G, _) => G.input(_));
  main.variable(observer("dashboard2")).define("dashboard2", ["d3", "options_2", "SVGTable", "ios_download", "miniChart2"], function* (d3, options_2, SVGTable, ios_download, miniChart2) {
    const svg = d3
      .create("svg")
      .attr("font-size", `${options_2.fontsize}pt`)
      .attr("viewBox", [0, 0, 975, 750]);

    yield svg.node(); // for autoSizeCell

    const table = new SVGTable(svg)
      .extent([[25, 25], [950, 400]])
      .fixedRows(+options_2.rows)
      .fixedColumns(+options_2.cols)
      .rowsPerPage(100)
      .autoSizeCell(true)
      .defaultColumnWidth(options_2.dataset === "china" ? 100 : 140)
      .defaultNumberFormat(options_2.dataset === "china" ? ",.0d" : ",.0f")
      .style({
        border: options_2.border,
        borderColor: options_2.borderColor,
        textColor: options_2.text,
        highlight: options_2.highlight,
        background: options_2.cell,
        headerBackground: options_2.header,
        fixedBackground: options_2.fixed,
        highlightBackground: options_2.highlightColor
      })
      .heatmap(options_2.heatmap)
      .heatmapPalette(d3.interpolateReds)
      .data(ios_download)
      .onhighlight((e, c) => {
        chart(c);
      });

    table.render();

    const chart = miniChart2(svg, 50, 450, 920, 250);
    return svg.node();
  }
  );
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`## Data`
    )
  });
  main.variable(observer("ios_income")).define("ios_income", ["options", "d3", "FileAttachment"], async function (options, d3, FileAttachment) {
    if (options.dataset === "china") {
      return d3.csvParse(await FileAttachment("china@1.csv").text(), d3.autoType);
    } else if (options.dataset === "japan") {
      return d3.csvParse(await FileAttachment("japan.csv").text(), d3.autoType);
    } else if (options.dataset === "korea") {
      return d3.csvParse(await FileAttachment("korea.csv").text(), d3.autoType);
    } else if (options.dataset === "taiwan") {
      return d3.csvParse(await FileAttachment("taiwan.csv").text(), d3.autoType);
    } else
      return d3.csvParse(await FileAttachment("usa.csv").text(), d3.autoType);
  }
  );
  main.variable(observer("ios_download")).define("ios_download", ["options_2", "d3", "FileAttachment"], async function (options_2, d3, FileAttachment) {
    if (options_2.dataset === "china") {
      return d3.csvParse(await FileAttachment("download_china.csv").text(), d3.autoType);
    }
    else if (options_2.dataset === "japan") {
      return d3.csvParse(await FileAttachment("download_japan.csv").text(), d3.autoType);
    }
    else if (options_2.dataset === "korea") {
      return d3.csvParse(await FileAttachment("download_korea.csv").text(), d3.autoType);
    }
    else if (options_2.dataset === "taiwan") {
      return d3.csvParse(await FileAttachment("download_taiwan.csv").text(), d3.autoType);
    }
    else
      return d3.csvParse(await FileAttachment("download_usa.csv").text(), d3.autoType);
  }
  );
  main.variable(observer("videoUrl")).define("videoUrl", ["FileAttachment"], async function (FileAttachment) {
    return (
      await FileAttachment(
        "World-wide game type IOS income (1)-1.mp4"
      ).url()
    )
  });
  main.variable(observer("performance_chart")).define("performance_chart", ["d3", "FileAttachment"], async function (d3, FileAttachment) {
    return (
      d3.csvParse(await FileAttachment("performance chart.csv").text(), d3.autoType)
    )
  });
  main.variable(observer("region_wise")).define("region_wise", ["FileAttachment"], function (FileAttachment) {
    return (
      FileAttachment("fina_data.json").json()
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`## Source Code`
    )
  });
  main.variable(observer("Paginator")).define("Paginator", ["d3"], function (d3) {
    return (
      class Paginator {
        constructor(table) {
          this._table = table;
          this._tableWidth = 0;
          this._tableHeight = 0;

          this._top = 0;
          this._left = 0;
          this._pw = 0;
          this._sw = 0;

          this._controls = {
            gotoInput: false,
            recordsPerPageSelector: true
          };
          this._options = {
            position: "top",
            selector: "left",
            buttonColor: "#aaa"
          }
          this._recordsPerPageSelections = [25, 50, 75];

          this._recordCount = 0;
          this._recordsPerPage = 50;
          this._currentPage = 1;
          this._totalPages = 0;
          this._currFloor = 0;
          this._currCeiling = 0;

          this._buttonPadding = 15;
          this._buttonSpacing = 5;
          this._containerTable = null;
          this._selectorCell = null;
          this._paginatorCell = null;

          this._onPageNumberChange = null;
          this._onRecordsPerPageChange = null;
        }

        controls(_) {
          return arguments.length ? (this._controls = _, this) : this._controls;
        }

        options(_) {
          return arguments.length ? (this._options = _, this) : this._options;
        }

        position(_) {
          return arguments.length ? (this._left = _[0], this._top = _[1], this) : [this._left, this.top];
        }

        buttonPadding(_) {
          return arguments.length ? (this._buttonPadding = _, this) : this._buttonPadding;
        }

        buttonSpacing(_) {
          return arguments.length ? (this._buttonSpacing = _, this) : this._buttonSpacing;
        }

        recordsPerPageSelections(_) {
          return arguments.length ? (this._recordsPerPageSelections = _, this) : this._recordsPerPageSelections;
        }

        recordsPerPage(_) {
          if (arguments.length) {
            this._recordsPerPage = _;
            this._totalPages = Math.ceil(this._recordCount / this._recordsPerPage);
            this._validateCurrentPage();
            return this;
          }
          else
            return this._recordsPerPage;
        }

        recordCount(_) {
          if (arguments.length) {
            this._recordCount = _;
            this._totalPages = Math.ceil(this._recordCount / this._recordsPerPage);
            this._validateCurrentPage();
            return this;
          }
          else
            return this._recordCount;
        }

        onPageNumberChange(_) {
          return arguments.length ? (this._onPageNumberChange = _, this) : this._onPageNumberChange;
        }

        onRecordsPerPageChange(_) {
          return arguments.length ? (this._onRecordsPerPageChange = _, this) : this._onRecordsPerPageChange;
        }

        init(recordsPerPage, recordCount) {
          this._recordsPerPage = recordsPerPage;
          this._recordCount = recordCount;
          this._totalPages = Math.ceil(this._recordCount / this._recordsPerPage);
          this._resetBoundary();
          return this;
        }

        render() {
          this._prepare();
          this._createContainers();
          this._renderPaginator();
          if (this._controls.recordsPerPageSelector) {
            this._renderRecordsPerPageSelector();
          }

          this._table.g.append(() => this._containerTable.node());
          return this;
        }

        _prepare() {
          const s = this._table.size();
          this._tableWidth = s[0];
          this._tableHeight = s[1];
        }

        _createContainers() {
          const c = d3.create("svg:g");
          if (this._options.position === "top")
            c.attr("transform", `translate(${this._left},${this._top})`);
          else
            c.attr("transform", `translate(${this._left},${this._top})`);

          this._containerTable = c;
          this._createSelectorCell();
          this._createPaginatorCell();
        }

        _createSelectorCell() {
          if (this._selectorCell) this._selectorCell.remove();
          this._selectorCell = this._containerTable.append("g");
        }

        _createPaginatorCell() {
          if (this._paginatorCell) this._paginatorCell.remove();
          this._paginatorCell = this._containerTable.append("g");
        }

        _renderPaginator(pnum) {
          this._createPaginatorCell();

          //if (this._controls.gotoInput) this._addGotoInput(pnum);
          var tx = 0;
          tx += this._addPageButton(1, tx);
          if (this._currFloor === 1 && this._currentPage < 5) {
            for (let i = 2; i <= this._currCeiling; i++)
              tx += this._addPageButton(i, tx);
          }
          else {
            var floor;
            if (this._totalPages === 5) {
              floor = 2;
            }
            else {
              floor = this._currFloor;
              tx += this._addSeperator(tx);
            }

            for (let i = floor; i <= this._currCeiling; i++) {
              tx += this._addPageButton(i, tx);
            }
          }

          if (this._currCeiling < this._totalPages) {
            tx += this._addSeperator(tx);
            tx += this._addPageButton(this._totalPages, tx);
          }

          this._pw = tx;
          this._adjust();
        }

        _renderRecordsPerPageSelector() {
          this._createSelectorCell();
          var tx = 0;
          this._recordsPerPageSelections.forEach(d => {
            tx += this._addSelectorButton(d, tx);
          });
          this._sw = tx;
          this._selectorCell.attr("transform", `translate(${this._tableWidth - tx},0)`);
        }

        _adjust() {
          const left = this._selectorCell && this._pw > this._tableWidth - this._sw ? this._pw + 30 : this._tableWidth - this._sw;
          this._selectorCell.attr("transform", `translate(${left},0)`);
        }

        _addSelectorButton(num, tx) {
          tx += this._buttonSpacing;
          const s = num.toString();
          const b = this._getBBox(s);
          this._selectorCell.append(() =>
            this._addButton(s, "selBtn", true, b.width, b.height, tx, num === this._recordsPerPage)
              .attr("num", num)
              .on("click", e => this._clickSelectorNumber(e))
              .node()
          );
          return b.width + this._buttonPadding + this._buttonSpacing;
        }

        _addPageButton(pageNum, tx) {
          tx += this._buttonSpacing;
          const s = pageNum.toString();
          const b = this._getBBox(s);
          this._paginatorCell.append(() =>
            this._addButton(s, "pageBtn", true, b.width, b.height, tx, pageNum === this._currentPage)
              .attr("pageNum", pageNum)
              .on("click", e => this._clickPageNumber(e))
              .node()
          );
          return b.width + this._buttonPadding + this._buttonSpacing;
        }

        _addSeperator(tx) {
          tx += this._buttonSpacing;
          const s = "...";
          const b = this._getBBox(s);
          this._paginatorCell.append(() => this._addButton(s, "seperator", false, b.width, b.height, tx).node());
          return b.width + this._buttonPadding + this._buttonSpacing;
        }

        _addButton(caption, className, rect, w, h, tx, selected) {
          const rw = w + this._buttonPadding,
            rh = h + this._buttonPadding / 2;

          return d3.create("svg:g")
            .attr("class", className)
            .attr("text-anchor", "middle")
            .attr("transform", `translate(${tx},0)`)
            .call(g => {
              if (rect)
                g.append("rect")
                  .attr("rx", 4).attr("ry", 4)
                  .attr("width", rw).attr("height", rh)
                  .attr("opacity", selected ? 1 : 0)
                  .attr("fill", this._options.buttonColor)
            })
            .call(g => g.append("text")
              .attr("transform", `translate(${rw / 2},${rh / 2 + h / 4})`)
              .text(caption));
        }

        _getBBox(str) {
          const svg = this._table.svg;
          if (!svg) return { width: 0, height: 0 };
          else {
            var t;
            try {
              t = svg.append("text").text(str);
              return t.node().getBBox();
            }
            finally {
              t.remove();
            }
          }
        }

        _gotoPage(pnum) {
          if (pnum < 1)
            pnum = 1;
          else if (pnum > this._totalPages)
            pnum = this._totalPages;

          if (pnum <= this._totalPages) {
            if (pnum >= 1 && pnum <= 4) {
              this._currFloor = 1;
              if (this._totalPages <= 5)
                this._currCeiling = this._totalPages;
              else
                this._currCeiling = 5;
            }
            else if (pnum >= this._totalPages - 4 && pnum <= this._totalPages) {
              this._currFloor = this._totalPages - 4;
              this._currCeiling = this._totalPages;
            }
            else {
              this._currFloor = pnum - 2;
              this._currCeiling = pnum + 1;
            }
          }
          this._currentPage = pnum;
          return this._currentPage;
        }

        _clickPageNumber(e) {
          var btn = e.currentTarget;
          var pnum = +btn.attributes["pageNum"].value;

          this._currentPage = pnum;
          if (pnum == this._currCeiling && pnum != this._totalPages) {
            this._currCeiling++;
            if (this._currCeiling + 2 >= this._totalPages) {
              this._currCeiling = this._totalPages;
              this._currFloor = this._totalPages - 4;
            }
            else
              this._currFloor = this._currCeiling - 3;
            this._renderPaginator();
          }
          else if (pnum == this._currFloor) {
            this._currFloor--;
            if (this._currFloor < 3)
              this._resetBoundary();
            else
              this._currCeiling = this._currFloor + 3;
            this._renderPaginator();
          }
          else if (pnum == 1) {
            this._resetBoundary();
            this._renderPaginator();
          }
          else if (pnum == this._totalPages && this._totalPages > 5) {
            this._currCeiling = this._totalPages;
            this._currFloor = this._totalPages - 4;
            this._renderPaginator();
          }
          else {
            this._paginatorCell
              .selectAll("rect")
              .nodes().forEach(node => {
                const num = +node.parentElement.attributes["pageNum"].value;
                node.setAttribute("opacity", num === this._currentPage ? 1 : 0);
              });
          }

          if (this._onPageNumberChange) {
            var r = this._getRange(pnum);
            this._onPageNumberChange(pnum, r.begin, r.end);
          }
        }

        _clickSelectorNumber(e) {
          var btn = e.currentTarget;
          var num = +btn.attributes["num"].value;

          this.recordsPerPage(num);
          this._selectorCell
            .selectAll("rect")
            .nodes().forEach(node => {
              const n = +node.parentElement.attributes["num"].value;
              node.setAttribute("opacity", num === n ? 1 : 0);
            });

          this._gotoPage(this._currentPage);

          this._renderPaginator();

          if (this._onRecordsPerPageChange) {
            var r = this._getRange(this._currentPage);
            this._onRecordsPerPageChange(this._recordsPerPage, this._currentPage, r.begin, r.end);
          }
        }

        _getRange(pnum) {
          var begin = (pnum - 1) * this._recordsPerPage;
          var end = begin + this._recordsPerPage - 1;
          return { begin: begin, end: end };
        }

        _validateCurrentPage() {
          if (this._currentPage > this._totalPages) {
            this._currentPage = this._totalPages;
            this._currCeiling = this._totalPages;
            this._currFloor = this._totalPages - 4;
          }
        }

        _resetBoundary() {
          this._currFloor = 1;
          this._currCeiling = this._totalPages <= 5 ? this._totalPages : 5;
        }
      }
    )
  });
  main.variable(observer("SVGTable")).define("SVGTable", ["Paginator", "d3", "Scrollbar"], function (Paginator, d3, Scrollbar) {
    return (
      class SVGTable {
        constructor(svg, container) {
          this._svg = svg;
          this._container = container || svg;
          this._g = null;
          this._charBox = { x: 0, y: 0, width: 0, height: 0 };

          this._autoSizeCell = true;
          this._defaultColumnWidth = 100;
          this._cellHeight = 24; // user setting
          this._cellHeightA = 24; // actual cell height = cellHeight + cellPaddingV * 2
          this._cellPaddingH = 10;
          this._cellPaddingV = 3;
          this._fixedColumns = 0;
          this._fixedRows = 0;

          this._left = 0;
          this._top = 0;
          this._width = 400;
          this._height = 300;
          this._widthA = 0;
          this._heightA = 0;
          this._sliderWidth = 13;
          this._sliderLength = 50;

          this._xf = 1; // horizontal content to scroll factor
          this._yf = 1; // vertical content to scroll factor
          this._minY = 0; // minimum y of the content can be scrolled
          this._fixedWidth = 0;
          this._fixedHeight = 0;

          this._data = null;
          this._fullData = null;
          this._dataIsArray = false;
          this._columns = null;
          this._defaultNumberFormat = "$,.2f";

          this._heatmap = false;
          this._heatmapPalette = null; // interpolator or array of colors
          this._heatmapColor = null;

          this._paginator = null;
          this._paginatorPos = "top";
          this._rowCount = 0;
          this._currPageNum = 0;
          this._rowsPerPage = 50;
          this._beginIndex = 0;
          this._endIndex = 49;
          this._rowsPerPageSelections = [25, 50, 75];

          this._scrollbar = {
            horizontal: null,
            vertical: null,
            visible: [true, true]
          };

          this._style = {
            border: true,
            borderColor: "#aaa",
            textColor: "black",
            background: "white",
            headerBackground: "#ddd",
            fixedBackground: "#eee",
            highlight: "cross", // none, cell, cross
            highlightBackground: "#fff3b0"
          };

          this._table = null;
          this._header = null;
          this._body = null;
          this._dataArea = null;
          this._dataHeader = null;

          this._focus = null;
          this._onsort = null;
          this._onchangepage = null;
          this._onhighlight = null;
          this._onclick = null;
          this._oncontextmenu = null;

          this._uniqueId = new String(Date.now() * Math.random()).replace(".", "");
        }

        defaultColumnWidth(_) {
          return arguments.length ? (this._defaultColumnWidth = +_, this) : this._defaultColumnWidth;
        }

        cellHeight(_) {
          return arguments.length ? (this._cellHeight = +_, this) : this._cellHeight;
        }

        cellPaddingH(_) {
          return arguments.length ? (this._cellPaddingH = +_, this) : this._cellPaddingH;
        }

        cellPaddingV(_) {
          return arguments.length ? (this._cellPaddingV = +_, this) : this._cellPaddingV;
        }

        autoSizeCell(_) {
          return arguments.length ? (this._autoSizeCell = _, this) : this._autoSizeCell;
        }

        fixedColumns(_) {
          return arguments.length ? (this._fixedColumns = +_, this) : this._fixedColumns;
        }

        fixedRows(_) {
          return arguments.length ? (this._fixedRows = +_, this) : this._fixedRows;
        }

        rowsPerPage(_) {
          return arguments.length ? (this._rowsPerPage = +_, this) : this._rowsPerPage;
        }

        rowsPerPageSelections(_) {
          return arguments.length ? (this._rowsPerPageSelections = _, this) : this._rowsPerPageSelections;
        }

        extent(_) {
          return arguments.length ? (
            this._left = +_[0][0], this._top = +_[0][1],
            this._width = +_[1][0], this._height = +_[1][1], this) : [[this._left, this._top], [this._width, this._height]];
        }

        size(_) {
          return arguments.length ? (this._width = +_[0], this._height = +_[1], this) : [this._width, this._height];
        }

        style(_) {
          return arguments.length ? (this._style = Object.assign(this._style, _), this) : this._style;
        }

        heatmap(_) {
          if (arguments.length) {
            this._heatmap = _;
            if (this._table) this._updateHeatmap();
            return this;
          }
          else
            return this._heatmap;
        }

        heatmapPalette(_) {
          if (arguments.length) {
            this._heatmapPalette = _;
            if (this._table) {
              this._processHeatmap();
              if (this._heatmap) this._updateHeatmap();
            }
            return this;
          }
          else
            return this._heatmapPalette;
        }

        data(_) {
          return arguments.length ? (this._data = _, this) : this._data;
        }

        columns(_) {
          if (arguments.length) {
            this._columns = _;
            return this;
          }
          else {
            if (!this._columns && this._data) this._processColumns();
            return this._columns;
          }
        }

        defaultNumberFormat(_) {
          return arguments.length ? (this._defaultNumberFormat = _, this) : this._defaultNumberFormat;
        }

        onsort(_) {
          return arguments.length ? (this._onsort = _, this) : this._onsort;
        }

        onchangepage(_) {
          return arguments.length ? (this._onchangepage = _, this) : this._onchangepage;
        }

        onhighlight(_) {
          return arguments.length ? (this._onhighlight = _, this) : this._onhighlight;
        }

        onclick(_) {
          return arguments.length ? (this._onclick = _, this) : this._onclick;
        }

        oncontextmenu(_) {
          return arguments.length ? (this._oncontextmenu = _, this) : this._oncontextmenu;
        }

        render() {
          if (!this._validate()) {
            // error
          }
          else {
            this._init();
            this._initPaginator();
            this._processColumns();
            this._prepare();

            this._calcConstrains();
            this._createClipPaths();

            this._processHeatmap();
            this._createTable();
            this._renderBody(this._table);
            this._renderHeader(this._table);
            this._addScrollbars();
            if (this._paginator) this._paginator.render();
          }
          return this;
        }

        getRowData(index) {
          return this._data[index];
        }

        getColumnData(index) {
          const c = this._columns[index];
          return this._data.map(_ => _[c.name]);
        }

        get g() { return this._g; }

        get svg() { return this._svg; }

        _init() {
          this._g = this._container.append("g");
          this._cellHeightA = this._cellHeight + this._cellPaddingV * 2;
          this._charBox = this._getBBox("Z");

          this._widthA = this._width;
          this._heightA = this._height;
        }

        _initPaginator() {
          if (this._data.length > this._rowsPerPage) {
            this._fullData = this._data;
            this._rowCount = this._fullData.length;
            this._data = this._fullData.slice(0, this._rowsPerPage);
            this._calcPageRange(1, 0);

            const pr = new Paginator(this);
            const ptop = this._top, ph = this._charBox.height + pr.buttonPadding() / 2 + 3; //3: margin
            this._top += ph;
            this._height -= ph;
            // bottom
            // this._height -= ph - 5;
            // ptop = this._height + this._top + 5;

            pr.init(this._rowsPerPage, this._rowCount)
              .options({
                position: "top",
                selector: "right",
                buttonColor: this._style.headerBackground
              })
              .position([this._left, ptop])
              .recordsPerPageSelections(this._rowsPerPageSelections)
              .onPageNumberChange((pnum, begin, end) => {
                this._currPageNum = pnum;
                this._calcPageRange(pnum, begin);
                this._pageData();
                this._rerender();
                if (this._onchangepage) this._onchangepage(this._beginIndex);
              })
              .onRecordsPerPageChange((rpp, pnum, begin, end) => {
                this._rowsPerPage = rpp;
                this._currPageNum = pnum;
                this._calcPageRange(pnum, begin);
                this._pageData();
                this._rerender();
                if (this._onchangepage) this._onchangepage(this._beginIndex);
              });

            this._paginator = pr;
          }
        }

        _calcPageRange(pnum, begin) {
          if (pnum === 1) this._beginIndex = this._fixedRows;
          else this._beginIndex = begin - (pnum - 2) * this._fixedRows;

          this._endIndex = this._beginIndex + this._rowsPerPage - this._fixedRows;
        }

        _pageData() {
          this._data = this._fullData.slice(0, this._fixedRows)
            .concat(this._fullData.slice(this._beginIndex, this._endIndex));
        }

        _rerender() {
          this._g.selectAll("clipPath").remove();
          if (this._table) this._table.remove();
          if (this._scrollbar.horizontal) this._scrollbar.horizontal.dispose();
          if (this._scrollbar.vertical) this._scrollbar.vertical.dispose();

          this._focus = null;
          this._height = this._heightA;
          this._width = this._widthA;
          this._scrollbar.visible = [true, true];

          const ph = this._charBox.height + this._paginator.buttonPadding() / 2;
          this._height -= ph;

          this._processColumns();
          this._prepare();

          this._calcConstrains();
          this._createClipPaths();

          this._createTable();
          this._renderBody(this._table);
          this._renderHeader(this._table);
          this._addScrollbars();
        }

        _validate() {
          return this._data && this._data.length > 0;
        }

        _prepare() {
          this._fixedHeight = this._cellHeightA * this._fixedRows + this._cellHeightA;

          const w = this._sumWidth();
          const h = this._data.length * this._cellHeightA;

          if (w + this._sliderWidth < this._width) {
            this._width = w;
            this._scrollbar.visible[0] = false;
          }
          else {
            this._width -= this._sliderWidth;
          }

          if (h + this._sliderWidth + this._cellHeightA < this._height) {
            this._height = h + this._cellHeightA; // includes header
            this._scrollbar.visible[1] = false;
          }
          else {
            this._height -= this._sliderWidth;
          }
        }

        _sumWidth(n) {
          // n === 0 : do not calculate, usually it is _fixedColumns = 0
          if (n === 0)
            return 0;
          else {
            // n === undefined : all columns
            const l = n || this._columns.length;
            var w = 0;
            for (let i = 0; i < l; i++) w += this._columns[i].width;
            return w;
          }
        }

        _processColumns() {
          if (this._data.length > 0 && this._data[0].length > 0) {
            this._dataIsArray = Array.isArray(this._data[0]);
          }

          if (!this._columns) {
            // CSV or JSON
            const keys = this._data.columns ? this._data.columns : Object.keys(this._data[0]);
            let x = 0;
            this._columns = keys.map((c, i) => {
              const isNumber = typeof this._data[0][c] === "number";
              const column = {
                name: c,
                isNumber: isNumber,
                format: isNumber ? this._defaultNumberFormat : null,
                order: 0, // 0: none, 1: ascending, 2: descending
                x: x,
                tx: x, // x for translate
                index: i,
                width: this._defaultColumnWidth
              }
              x += column.width;
              return column;
            });
          }
          else {
            let x = 0;
            this._columns.forEach((column, i) => {
              column.width = column.width || this._defaultColumnWidth;
              column.x = x;
              column.tx = x; // x for translate
              column.index = i;
              x += column.width;
            });
          }

          if (this._autoSizeCell) this._calcSize();

          this._fixedWidth = this._sumWidth(this._fixedColumns);
          for (let i = this._fixedColumns; i < this._columns.length; i++) {
            const c = this._columns[i];
            c.tx = c.x - this._fixedWidth; // x for translate
          }

          this._columns.resetOrder = (except) => this._columns.forEach(c => { if (except && c !== except || !except) c.order = 0; });
        }

        _calcSize() {
          // test if it is used in a generator
          if (this._charBox.width > 0 && this._charBox.height > 0) {

            // overrides cellHeight
            this._cellHeight = this._charBox.height;
            this._cellHeightA = this._charBox.height + this._cellPaddingV * 2;

            // prepare keys
            const keys = [];
            const longest = this._columns.map((column, i) => {
              if (this._dataIsArray) keys.push(i);
              else keys.push(column.name);
              return column.name;
            });

            // find the longest string for each column
            for (let i = 0; i < this._data.length; i++) {
              const row = this._data[i];
              for (let j = 0; j < keys.length; j++) {
                const key = keys[j], column = this._columns[j];
                const val = row[key];
                if (val) {
                  const curr = column.isNumber && column.format ? d3.format(column.format)(row[key]) : row[key];
                  if (curr.length > longest[j].length) longest[j] = curr;
                }
              }
            }

            // re-calculate column width for each column based on longest[]
            var x = 0;
            for (let i = 0; i < longest.length; i++) {
              const column = this._columns[i];
              column.x = column.tx = x;
              column.width = this._getBBox(longest[i]).width + this._cellPaddingH * 2 + 20;
              x += column.width;
            }
          }
        }

        _getBBox(str) {
          var t;
          try {
            t = this._svg.append("text").text(str);
            return t.node().getBBox();
          }
          finally {
            t.remove();
          }
        }

        _processHeatmap() {
          if (!this._heatmapPalette) return;

          const data = this._fullData || this._data;
          const all = data.slice(this._fixedRows).flatMap(d => {
            const r = this._dataIsArray ?
              d.slice(this._fixedColumns) :
              Object.keys(d).map(k => d[k]).slice(this._fixedColumns);

            const values = [];
            for (let i = 0; i < r.length; i++) {
              const col = this._columns[i + this._fixedColumns];
              if (col.isNumber) values.push(this._dataIsArray ? r[i] : r[col.name]);
            }
            return r;
          })

          const ext = d3.extent(all);
          const p = this._heatmapPalette;
          if (Array.isArray(p)) {
            // Palette is an array
            this._heatmapColor = d3.scaleSequential()
              .domain(this._series(ext[0], ext[1], p.length))
              .range(p);
          }
          else if (typeof p === "function") {
            // Palette is a color interpolator
            this._heatmapColor = d3.scaleSequential(p)
              .domain(ext);
          }
        }

        _series(min, max, num) {
          const n = num - 1, s = [min], intrv = max / n;
          var i = min;
          while (i < max && s.length < num) {
            i += intrv;
            s.push(i);
          }

          if (s.length < num)
            s.push(max);
          else
            s[s.length - 1] = max;

          return s;
        }

        _createClipPaths() {
          const addClipPath = (id, width, height, x, y) => {
            const cp = this._g.append("clipPath")
              .attr("id", `${id}.${this._uniqueId}`)
              .append("rect")
              .attr("width", width)
              .attr("height", height);

            if (x) cp.attr("x", x);
            if (y) cp.attr("y", y);
          }

          addClipPath("bodyClip", this._width, this._height);
          addClipPath("headerRowClip", this._width - this._fixedWidth, this._fixedHeight + 1, null, -1);
          this._columns.forEach((column, i) => {
            addClipPath("headerClip" + i, column.width - this._cellPaddingH, this._cellHeightA);
            if (column.isNumber)
              addClipPath("cellClip" + i, column.width - this._cellPaddingH, this._cellHeightA, -(column.width - this._cellPaddingH));
            else
              addClipPath("cellClip" + i, column.width - this._cellPaddingH, this._cellHeightA);
          })
        }

        _clipPath(id) {
          return `url(#${id}.${this._uniqueId})`;
        }

        _createTable() {
          // table container
          this._table = this._g.append("g")
            .attr("transform", `translate(${this._left},${this._top})`)
            .on("wheel", e => this._scroll(e))
            .on("mousewheel", e => this._scroll(e))
            .on("DOMMouseScroll", e => this._scroll(e));
        }

        _renderBody() {
          const that = this, style = this._style,
            highlight = style.highlight !== "none",
            cross = style.highlight === "cross";

          // table body container
          const bodyBox = this._table.append("g").attr("clip-path", this._clipPath("bodyClip"));
          // inner container of the table body, y is controlled by vertical scrollbar and its content is clipped by bodyClip  
          // it contains two parts: dataArea which is horizontally moveable and fixed columns on the left
          const body = bodyBox.append("g").attr("transform", `translate(0,${this._fixedHeight})`);
          // container of the moveable part of the body
          const dataArea = body.append("g")
            .attr("transform", `translate(${this._fixedWidth},0)`);

          const rows = this._data.slice(this._fixedRows);
          //if (this._dataIsArray) rows.forEach(r => r[0].origin = r);
          // moveable part of the body, x is controlled by horizontal scrollbar
          const cell = this._addRows(
            dataArea,
            "row",
            () => rows,
            (d, i) => this._columns.slice(this._fixedColumns).map((c, j) => {
              return {
                rowIndex: i + this._fixedRows,
                column: c,
                value: this._dataIsArray ? d[c.index] : d[c.name]
              }
            }),
            (d, i) => `translate(0,${i * this._cellHeightA})`,
            d => `translate(${d.column.tx},0)`,
            g => this._addCell(g, style.background, this._fixedColumns))
            .on("click", click)
            .on("contextmenu", contextmenu)
            .on("mouseover", mouseover)
            .on("mouseleave", mouseleave);

          var fixedCell;
          if (this._fixedColumns) {
            // fixed columns on the left
            fixedCell = this._addRows(
              body.append("g"),
              "row",
              () => rows.map((r, i) => this._columns.slice(0, this._fixedColumns).map((c, j) => ({
                origin: r, // for sort to get the index of data
                rowIndex: i + this._fixedRows,
                column: c,
                value: this._dataIsArray ? r[c.index] : r[c.name]
              }))),
              d => d,
              (d, i) => `translate(0,${i * this._cellHeightA})`,
              d => `translate(${d.column.tx},0)`,
              g => this._addCell(g, style.fixedBackground, 0, false, true));
          }

          this._body = body;
          this._dataArea = dataArea;

          const test = cross ?
            (d, cell) => cell.rowIndex === d.rowIndex || cell.column.index === d.column.index :
            (d, cell) => cell.rowIndex === d.rowIndex && cell.column.index === d.column.index;

          d3.select("body").on(`keydown.eric.svgtable.${this._uniqueId}`, keypress);

          function keypress(e) {
            if (e.key === "Escape") that._focus = null;
          }

          function click(e, d) {
            if (that._focus !== d) {
              that._focus = null;
              mouseover(e, d);
              that._focus = d;
            }
            else
              that._focus = null;

            if (that._onclick) that._onclick(e, d);
          }

          function contextmenu(e, d) {
            if (that._oncontextmenu) {
              if (that._focus !== d) {
                that._focus = null;
                mouseover(e, d);
                that._focus = d;
                that._oncontextmenu(e, d);
              }
              return false;
            }
          }

          function mouseover(e, d) {
            if (!highlight || that._focus) return;

            const r = cell.select("rect")
              .datum(cell => test(d, cell) ? style.highlightBackground : that._cellColor(cell, style.background, false, false))
              .attr("fill", d => d);
            if (!that._style.border) r.attr("stroke", d => d);

            if (fixedCell) fixedCell.select("text").attr("font-weight", cell => cell.rowIndex === d.rowIndex ? "bold" : "");
            that._dataHeader.selectAll("text").attr("font-weight", cell => cell.column.index === d.column.index ? "bold" : "");

            if (that._onhighlight) {
              that._onhighlight(e, {
                cell: d,
                column: d.column,
                getRow: () => that.getRowData(d.rowIndex),
                getColumn: () => that.getColumnData(d.column.index)
              });
            }
          }

          function mouseleave() {
            if (!highlight || that._focus) return;

            const r = cell.select("rect").attr("fill", d => that._cellColor(d, style.background, false, false));
            if (!that._style.border) r.attr("stroke", d => that._cellColor(d, style.background, false, false));

            if (fixedCell) fixedCell.select("text").attr("font-weight", "");
            that._dataHeader.selectAll("text").attr("font-weight", "");
          }
        }

        _updateHeatmap() {
          const bg = this._style.background;
          const rects = this._dataArea.selectAll("rect");
          if (this._heatmap) {
            rects.attr("fill", d => this._cellColor(d, bg, false, false));
            if (!this._style.border) rects.attr("stroke", d => this._cellColor(d, bg, false, false));
          }
          else {
            rects.attr("fill", d => bg);
            if (!this._style.border) rects.attr("stroke", bg);
          }
        }

        _renderHeader(g) {
          const style = this._style;

          // fixed rows sliced from this._data
          const rows = this._data.slice(0, this._fixedRows);
          // header container
          const header = g.append("g");
          // top-left cells which are always fixed if fixedColumns is specified
          header.selectAll(".column")
            // Unify the the data structure make it compatible with addCell
            .data(this._columns.slice(0, this._fixedColumns).map((d, i) => ({
              column: d
            })))
            .join("g")
            .attr("class", "column")
            .attr("transform", d => `translate(${d.column.tx},0)`)
            .call(g => this._addCell(g, style.headerBackground, 0, true, true))
            .on("click", (e, d) => this._sort(d));

          // fixed data cells in the fixed columns section
          if (this._fixedColumns) {
            this._addRows(
              header,
              "fixedRow",
              () => rows.map((r, i) => this._columns.slice(0, this._fixedColumns).map((c, j) => ({
                rowIndex: i,
                column: c,
                value: this._dataIsArray ? r[c.index] : r[c.name]
              }))),
              d => d,
              (d, i) => `translate(0,${(i + 1) * this._cellHeightA})`,
              d => `translate(${d.column.tx},0)`,
              g => this._addCell(g, style.fixedBackground, 0, false, true));
          }

          // the container of the rest of the header cells, its content is clipped by headerClip
          const headerBox = header.append("g")
            .attr("clip-path", this._clipPath("headerRowClip"))
            .attr("transform", `translate(${this._fixedWidth},0)`);

          // horizontally moveable part of the header, x is controlled by and synchronized with horizontal scrollbar
          const dataHeader = headerBox.append("g");
          dataHeader.selectAll(".column")
            // Unify the the data structure make it compatible with addCell
            .data(this._columns.slice(this._fixedColumns).map((d, i) => ({
              column: d
            })))
            .join("g")
            .attr("class", "column")
            .attr("transform", d => `translate(${d.column.tx},0)`)
            .call(g => this._addCell(g, style.headerBackground, this._fixedColumns, true, true))
            .on("click", (e, d) => this._sort(d));

          this._addRows(
            dataHeader,
            "fixedRow",
            () => rows,
            (d, i) => this._columns.slice(this._fixedColumns).map((c, j) => {
              return {
                rowIndex: i,
                column: c,
                value: this._dataIsArray ? d[c.index] : d[c.name]
              }
            }),
            (d, i) => `translate(0,${(i + 1) * this._cellHeightA})`,
            d => `translate(${d.column.tx},0)`,
            g => this._addCell(g, style.fixedBackground, this._fixedColumns, false, true)
          );

          // a fixed line for seperating header and body
          g.append("line")
            .attr("stroke", style.borderColor)
            .attr("x1", 0)
            .attr("y1", this._cellHeightA)
            .attr("x2", this._width)
            .attr("y2", this._cellHeightA);

          this._header = header;
          this._dataHeader = dataHeader;
        }

        _sort(d) {
          const sorted = this._sortData(d.column);

          if (this._paginator && this._fullData.length > this._rowsPerPage) {
            const x = this._getX(), y = this._getY();
            this._pageData();
            this._rerender();
            this._moveX(x);
            this._moveY(y);
            if (this._onsort) this._onsort(d.column, this._paginator !== null);
          }
          else {
            const f = 250 / sorted.length;
            this._table.selectAll(".row")
              .transition()
              .duration((d, i) => i * f)
              .ease(d3.easeBounce)
              .attr("transform", d => {
                const i = Array.isArray(d) && d[0].origin !== undefined ? sorted.indexOf(d[0].origin) : sorted.indexOf(d);
                return `translate(0,${i * this._cellHeightA})`;
              });
          }

          const cg = this._header.selectAll(".column");
          cg.select(".asc").attr("fill", _ => d.column === _.column && d.column.order === 1 ? "#777" : "#bbb");
          cg.select(".desc").attr("fill", _ => d.column === _.column && d.column.order === 2 ? "#777" : "#bbb");
        }

        _sortData(column) {
          //var sorted = [...this._data].slice(this._fixedRows);
          var fixed, sorted;
          if (this._paginator) {
            if (this._fixedRows > 0) {
              fixed = this._fullData.slice(0, this._fixedRows);
              sorted = this._fullData.slice(this._fixedRows);
            }
            else
              sorted = this._fullData;
          }
          else {
            sorted = [...this._data].slice(this._fixedRows);
          }

          this._columns.resetOrder(column);
          if (column.order === 0)
            column.order = 1;
          else if (column.order === 1)
            column.order = 2;
          else
            column.order = 1;

          const index = this._dataIsArray ? column.index : column.name;

          if (column.order === 0) {
            sorted.sort((a, b) => -1);
          }
          else if (column.isNumber) {
            if (column.order === 1)
              sorted.sort((a, b) => a[index] - b[index]);
            else
              sorted.sort((a, b) => b[index] - a[index]);
          }
          else {
            if (column.order === 1)
              sorted.sort((a, b) => a[index].localeCompare(b[index]));
            else
              sorted.sort((a, b) => b[index].localeCompare(a[index]));
          }

          if (fixed) this._fullData = fixed.concat(sorted);

          return sorted;
        }

        // rows: data function for rows
        // columns: data function for columns
        // rt: row translate function
        // ct: column translate function
        // cell: cell function
        _addRows(g, className, rows, columns, rt, ct, cell) {
          return g.selectAll("." + className)
            .data(rows)
            .join("g")
            .attr("class", className)
            .attr("transform", rt)
            .selectAll(".cell")
            .data(columns)
            .join("g")
            .attr("class", "cell")
            .attr("transform", ct)
            .call(cell)
        }

        // base: number of fixed cells on the same row
        _addCell(g, fill, base, isHeader, isFixed) {
          const style = this._style;

          const rect = g.append("rect")
            .attr("width", d => d.column.width)
            .attr("height", this._cellHeightA)
            .attr("fill", d => this._cellColor(d, fill, isHeader, isFixed))
            .attr("stroke-width", 0.1)
            .attr("stroke", style.border ? style.borderColor : fill);

          if (this._heatmap && !(isHeader || isFixed)) rect.attr("opacity", 0.5);

          const t = g.append("text").attr("y", "1em").attr("dy", this._cellPaddingV).attr("fill", style.textColor);

          if (isHeader) {
            if (!style.border)
              g.append("line")
                .attr("x1", d => d.column.width - 1).attr("y1", 5)
                .attr("x2", d => d.column.width - 1).attr("y2", this._cellHeightA - 5)
                .attr("stroke", style.borderColor);

            this._arrow(g, base, "asc", "M 0 8 L 3 4 L 6 8");
            this._arrow(g, base, "desc", "M 0 11 L 3 15 L 6 11");

            // Header cell
            t.attr("dx", this._cellPaddingH)
              .attr("clip-path", d => this._clipPath(`headerClip${d.column.index}`))
              .text(d => d.column.name);
          }
          else {
            t.attr("class", "value")
              .attr("dx", d => d.column.isNumber ? -this._cellPaddingH : this._cellPaddingH)
              .attr("clip-path", d => this._clipPath(`cellClip${d.column.index}`))
              .attr("transform", d => `translate(${d.column.isNumber ? d.column.width : 0},0)`)
              .attr("text-anchor", d => d.column.isNumber ? "end" : "start")
              .text(d => {
                if (d.column.isNumber && d.column.format)
                  return d3.format(d.column.format)(d.value);
                else
                  return d.value;
              });
          }
        }

        _cellColor(d, fill, isHeader, isFixed) {
          if (this._heatmap) {
            if (isHeader || isFixed || !d.column.isNumber)
              return fill;
            else
              return this._heatmapColor(d.value);
          }
          else
            return fill;
        }

        _arrow(g, base, name, path) {
          g.append("path")
            .attr("class", name)
            .attr("d", path)
            .attr("fill", "#bbb")
            .attr("transform", d => `translate(${d.column.width - this._cellPaddingH - 10},2)`);
        }

        _addScrollbars() {
          if (this._scrollbar.visible[1]) this._addVScroll();
          if (this._scrollbar.visible[0]) this._addHScroll();
        }

        _addVScroll() {
          const sb = this._scrollbar.vertical = new Scrollbar(this._svg);
          sb.position(this._left + this._width, this._top + this._fixedHeight, this._height - this._fixedHeight)
            .sliderWidth(this._sliderWidth)
            .sliderLength(this._sliderLength)
            .onscroll((y, sy, delta) => this._body.attr("transform", `translate(0,${-sy * this._yf + this._fixedHeight})`))
            .attach();
        }

        _addHScroll() {
          const sb = this._scrollbar.horizontal = new Scrollbar(this._svg);
          sb.vertical(false)
            .position(this._left + this._fixedWidth, this._top + this._height, this._width - this._fixedWidth)
            .sliderWidth(this._sliderWidth)
            .sliderLength(this._sliderLength)
            .onscroll((x, sx, delta) => {
              this._dataArea.attr("transform", `translate(${-sx * this._xf + this._fixedWidth},0)`);
              this._dataHeader.attr("transform", `translate(${-sx * this._xf},0)`);
            })
            .attach();
        }

        _calcConstrains() {
          // f for both scrollbars = (total - visible) / (visible - slider length)    
          // Vertical scrollbar constrain        
          const th = (this._data.length - this._fixedRows) * this._cellHeightA,
            sh = this._height - this._fixedHeight;
          this._yf = (th - sh) / (sh - this._sliderLength);

          // Horizontal scrollbar constrain
          const tw = this._sumWidth() - this._sumWidth(this._fixedColumns),
            sw = this._width - this._sumWidth(this._fixedColumns);
          this._xf = (tw - sw) / (sw - this._sliderLength);

          this._minX = -(tw - this._width);
          this._minY = -((this._data.length - this._fixedRows) * this._cellHeightA - this._height);
        }

        _scroll(e) {
          if (this._scrollbar.vertical) {
            const dy = e.wheelDeltaY ? e.wheelDeltaY : e.wheelDelta ? e.wheelDelta : -1;
            if (dy === -1) return;

            const cy = this._getY();
            var y = cy + dy;
            this._moveY(y);
          }

          if (this._scrollbar.horizontal) {
            const dx = e.wheelDeltaX;
            if (dx) {
              const cx = this._getX();
              var x = cx + dx;
              this._moveX(x);
            }
          }
          e.preventDefault();
        }

        _getX() { return +this._dataArea.attr("transform").split(",")[0].substring(10); }
        _getY() { return +this._body.attr("transform").split(",")[1].replace(")", ""); }

        _moveX(x) {
          if (x > this._fixedWidth) x = this._fixedWidth;
          else if (x < this._minX) x = this._minX;

          this._dataArea.attr("transform", `translate(${x},0)`);
          this._dataHeader.attr("transform", `translate(${x - this._fixedWidth},0)`);
          if (this._scrollbar.horizontal)
            this._scrollbar.horizontal.moveSlider(-((x - this._fixedWidth) / this._xf));
        }

        _moveY(y) {
          if (y < this._minY) y = this._minY;
          else if (y > this._fixedHeight) y = this._fixedHeight;

          this._body.attr("transform", `translate(0,${y})`);
          if (this._scrollbar.vertical)
            this._scrollbar.vertical.moveSlider(-(y - this._fixedHeight) / this._yf);
        }
      }
    )
  });
  main.variable(observer("Scrollbar")).define("Scrollbar", ["d3"], function (d3) {
    return (
      class Scrollbar {
        constructor(svg) {
          this._svg = svg;
          this._g = null;
          this._box = null;
          this._vertical = true;
          this._bar = null;
          this._slider = null;

          this._sliderWidth = 13;
          this._sliderLength = 50;

          this._sliderTimer = null;
          this._sliderTimeout = 300;
          this._sliderSteps = null;

          this._grabbing = false;
          this._delta = 0;
          this._deltac = 0;

          this._onscroll = null;
          this._namespace = `eric.scrollbar.${Date.now() * Math.random()}`;
        }

        vertical(_) {
          return arguments.length ? (this._vertical = _, this) : this._vertical;
        }

        sliderWidth(_) {
          return arguments.length ? (this._sliderWidth = _, this) : this._sliderWidth;
        }

        sliderLength(_) {
          return arguments.length ? (this._sliderLength = _, this) : this._sliderLength;
        }

        position(x, y, length) {
          return arguments.length ? (this._box = { x, y, length }, this) : this._box;
        }

        onscroll(_) {
          return arguments.length ? (this._onscroll = _, this) : this._onscroll;
        }

        attach() {
          this._render();
          this._attachEvents();
        }

        dispose() {
          if (this._g) this._g.remove();
          d3.select("body")
            .on(`mousedown.${this._namespace}`, null)
            .on(`mouseup.${this._namespace}`, null)
            .on(`mousemove.${this._namespace}`, null);
        }

        moveSlider(pos) {
          if (pos < 0)
            pos = 0;
          else if (pos + this._sliderLength > this._box.length)
            pos = this._box.length - this._sliderLength;

          this._slider.attr(this._vertical ? "y" : "x", pos);
        }

        _render() {
          if (this._vertical)
            this._renderVBar();
          else
            this._renderHBar();
        }

        _renderVBar() {
          const box = this._box;

          const g = this._svg.append("g")
            .attr("transform", `translate(${box.x},${box.y})`);

          this._bar = g.append("rect")
            .attr("width", this._sliderWidth)
            .attr("height", box.length)
            .attr("fill", "#eee");

          this._slider = g.append("rect")
            .attr("x", 0).attr("y", 0)
            .attr("width", this._sliderWidth)
            .attr("height", this._sliderLength)
            .attr("fill", "#ccc");

          this._g = g;
        }

        _renderHBar() {
          const box = this._box;

          const g = this._svg.append("g")
            .attr("transform", `translate(${box.x},${box.y})`);

          this._bar = g.append("rect")
            .attr("width", box.length)
            .attr("height", this._sliderWidth)
            .attr("fill", "#eee");

          this._slider = g.append("rect")
            .attr("x", 0).attr("y", 0)
            .attr("width", this._sliderLength)
            .attr("height", this._sliderWidth)
            .attr("fill", "#ccc");

          this._g = g;
        }

        _attachEvents(tbox) {
          const box = this._box;

          //this._svg
          d3.select("body")
            .on(`mousedown.${this._namespace}`, e => {
              if (e.buttons === 1) {
                const p = d3.pointer(e);
                if (e.srcElement === this._slider.node()) {
                  this._grabbing = true;
                  this._slider.attr("fill", "#aaa");
                  if (this._vertical) {
                    this._delta = p[1] - +this._slider.attr("y");
                    this._deltac = p[1] - +this._slider.attr("y") - this._sliderLength / 2;
                  }
                  else {
                    this._delta = p[0] - +this._slider.attr("x");
                    this._deltac = p[0] - +this._slider.attr("x") - this._sliderWidth / 2;
                  }
                  e.stopPropagation();
                }
                else if (e.srcElement === this._bar.node()) {
                  const cbox = this._bar.node().getBoundingClientRect();

                  var a, b, pos;
                  if (this._vertical) {
                    a = pos = +this._slider.attr("y");
                    b = p[1] - cbox.y;
                  }
                  else {
                    a = pos = +this._slider.attr("x");
                    b = p[0] - cbox.x;
                  }

                  const intr = (b - a) / 4;
                  const steps = [];
                  for (var i = 0; i < 3; i++) {
                    pos += intr;
                    steps.push(pos);
                  }

                  if (b + this._sliderLength > this._box.length)
                    steps.push(this._box.length - this._sliderLength);
                  else
                    steps.push(b);

                  this._sliderSteps = steps.reverse();
                  this._sliderTimeout = 200;
                  this._sliderTimer = setTimeout(() => this._slide(), this._sliderTimeout);
                  e.stopPropagation();
                }
              }
            })
            .on(`mouseup.${this._namespace}`, () => {
              if (this._sliderTimer) clearTimeout(this._sliderTimer);
              const steps = this._sliderSteps;
              if (steps && steps.length > 0) {
                this._slideTo(steps.reverse().pop());
                this._sliderSteps = null;
              }

              this._grabbing = false;
              this._slider.attr("fill", "#ccc");
            })
            .on(`mousemove.${this._namespace}`, e => {
              const box = this._box;

              if (this._grabbing) {
                if (this._vertical) {
                  const y = d3.pointer(e)[1];
                  const sy = y - this._delta;
                  if (sy >= 0 && sy <= box.length - this._sliderLength) {
                    this._slider.attr("y", sy);
                    if (this._onscroll) this._onscroll(y, sy, this._deltac);
                  }
                }
                else {
                  const x = d3.pointer(e)[0];
                  const sx = x - this._delta;
                  if (sx >= 0 && sx <= box.length - this._sliderLength) {
                    this._slider.attr("x", sx);
                    if (this._onscroll) this._onscroll(x, sx, this._deltac);
                  }
                }
              }
            });
        }

        _slideTo(dest) {
          this._slider.attr(this._vertical ? "y" : "x", dest);
          if (this._onscroll) this._onscroll(dest, dest, 0);
        }

        _slide() {
          this._slideTo(this._sliderSteps.pop());
          if (this._sliderSteps.length > 0) {
            this._sliderTimeout -= 50;
            this._sliderTimer = setTimeout(() => this._slide(), this._sliderTimeout);
          }
          else
            this._sliderTimer = null;
        }
      }
    )
  });
  main.variable(observer("PerformanceChart")).define("PerformanceChart", ["d3"], function (d3) {
    return (
      class PerformanceChart {
        constructor(container) {
          this._container = container;

          // Groups
          this._cg = null;
          this._g = null;
          this._og = null;
          this._ig = null;

          // Visual elements and selections
          this._dots = null;
          this._highlighter = null;
          this._rankAxis = null;
          this._zeroLine = null;
          this._uncLabel = null;
          this._textBox = null;
          this._charBox = null;
          this._infoBox = null;
          this._legendBox = null;

          // Extents
          this._pMin = 0;
          this._pMax = 0;
          this._nMin = 0;
          this._nMax = 0;
          this._rMin = 0;
          this._rMax = 0;

          // Base variables and constants
          this._width = 0;
          this._height = 0;
          this._shift = null;
          this._maxY = 0;
          this._leftMargin = 0;
          this._innerMargin = 0;
          this._legendHeight = 0;
          this._dotRadius = 1;
          this._dotDiameter = 3;
          this._maxUnchangedCount = 0;
          this._level = 0;
          this._defaultLevel = 0;

          // Shortcuts
          this._isNumber = false;
          this._isGrowth = true;
          this._isRate = false;
          this._isCircle = true;

          // Scales
          this._rk = null;
          this._x = null;
          this._y = null;
          this._yu = null;
          this._cp = null;
          this._cn = null;

          // Data and options
          this._options = {
            number: "growth",
            isolateUnchanged: true,
            posPalette: d3.interpolateYlGnBu,
            negPalette: d3.interpolateYlOrRd,
            shape: "circle",
            clickAction: "highlight",
            showSlider: true,
            fontFamily: "sans-serif",
            fontSize: "10px",
            debug: false
          };

          this._tick = {
            name: "",
            isDate: false,
            format: "",
            interval: "auto",
            extractor: null,
            color: "black"
          };

          this._tooltip = {
            color: "black",
            boxColor: "white",
            boxOpacity: 0.8
          };

          this._color = {
            legend: "black",
            hover: "#999",
            highlighter: "#eee",
            unchanged: "#aaa"
          };

          this._data = null;
          this._chartData = null;
          this._keys = null;
          this._focusedKey = null;
          this._focusedRange = null;
          this._uniqueId = new String(Date.now() * Math.random()).replace(".", "");

          // events
          this._onhover = null;
          this._onclick = null;
          this._oncancel = null;
        }

        size(_) {
          return arguments.length
            ? ((this._width = _[0]), (this._height = _[1]), this)
            : [this._width, this._height];
        }

        options(_) {
          return arguments.length
            ? ((this._options = Object.assign(this._options, _)), this)
            : this._options;
        }

        tick(_) {
          return arguments.length
            ? ((this._tick = Object.assign(this._tick, _)), this)
            : this._tick;
        }

        color(_) {
          return arguments.length
            ? ((this._color = Object.assign(this._color, _)), this)
            : this._color;
        }

        tooltip(_) {
          return arguments.length
            ? ((this._tooltip = Object.assign(this._tooltip, _)), this)
            : this._tooltip;
        }

        data(_) {
          return arguments.length ? ((this._data = _), this) : this._data;
        }

        onhover(_) {
          return arguments.length ? ((this._onhover = _), this) : this._onhover;
        }

        onclick(_) {
          return arguments.length ? ((this._onclick = _), this) : this._onclick;
        }

        oncancel(_) {
          return arguments.length ? ((this._oncancel = _), this) : this._oncancel;
        }

        render() {
          this._init();
          this._process();
          this._calcShift();
          this._calcLeftMargin();
          this._calcConstants();
          this._initScales();
          this._render();
          return this;
        }

        _init() {
          const options = this._options;

          this._textBox = this._container
            .append("text")
            .attr("font-family", this._options.fontFamily)
            .attr("font-size", this._options.fontSize)
            .style("visibility", "hidden");

          this._getCharBox();
          this._legendHeight = this._charBox.height * 3;
          this._innerMargin = this._charBox.height * 2;

          this._isNumber = options.number === "value";
          this._isGrowth = options.number === "growth";
          this._isRate = !this._isNumber && !this._isGrowth;
          this._isCircle = options.shape === "circle";
        }

        _process(update) {
          this._processKeys();
          const start = this._isNumber ? 0 : 1,
            cd = Array(this._data.length - start);

          // Set level to average if number is value
          if (!update && this._isNumber) {
            const total = this._data
              .flatMap(d => this._keys.map(k => +d[k]))
              .reduce((a, b) => a + b);
            this._defaultLevel = this._level =
              total / (this._data.length * this._keys.length);
          }

          for (let i = start; i < this._data.length; i++) {
            let unc = 0;
            const tick = this._data[i][this._tick.name];

            // Extract values by key, calculate growth and rate
            const values = this._keys.map(key => {
              const number = +this._data[i][key],
                prevValue = i === 0 ? 0 : +this._data[i - 1][key],
                growth = number - prevValue;

              let rate = 0;
              if (growth === 0) {
                unc++;
                if (prevValue === 0) rate = 0;
                // avoid NaN and it is unchanged
                else rate = growth / prevValue;
              } else rate = growth / prevValue;

              return { index: i, tick, key, number, growth, rate };
            });

            if (unc > this._maxUnchangedCount) this._maxUnchangedCount = unc;
            this._rankValues(values);

            cd[i - start] = { tick, values };
          }
          this._chartData = cd;
        }

        _processKeys() {
          const keys = Object.keys(this._data[0]);

          if (this._tick.name === "") {
            this._tick.name = keys[0];
            this._keys = keys.slice(1);
          } else {
            const index = keys.indexOf(this._tick.name);
            if (index > -1) {
              keys.splice(index, 1);
              this._keys = keys;
            } else throw "Invalid tick field.";
          }
        }

        _rankValues(values) {
          const level = this._level,
            isounc = this._options.isolateUnchanged;

          let pos = 0;
          values.sort((a, b) => this._getValue(b) - this._getValue(a));
          // Rank positive section
          values
            .filter(d => {
              const v = this._getValue(d),
                g = this._isNumber ? d.growth : v;

              if (isounc ? g !== 0 && v >= level : v >= level) {
                if (v !== Number.POSITIVE_INFINITY && v > this._pMax) this._pMax = v;
                else if (v < this._pMin) this._pMin = v;
                return true;
              } else return false;
            })
            .forEach((d, i) => {
              d.rank = i + 1;
              d.pos = pos++;
              if (d.rank > this._rMax) this._rMax = d.rank;
              else if (d.rank < this._rMin) this._rMin = d.rank;
            });

          // Rank negative section
          values
            .filter(d => {
              const v = this._getValue(d),
                g = this._isNumber ? d.growth : v;

              if (isounc ? g !== 0 && v < level : v < level) {
                if (v > this._nMax) this._nMax = v;
                else if (v < this._nMin) this._nMin = v;
                return true;
              } else return false;
            })
            .forEach((d, i) => {
              d.rank = -(i + 1);
              d.pos = pos++;
              if (d.rank > this._rMax) this._rMax = d.rank;
              else if (d.rank < this._rMin) this._rMin = d.rank;
            });
        }

        _calcShift() {
          var a = 0,
            b = this._keys.length;
          var da = null,
            db = null;

          this._chartData.forEach(d => {
            let c = d.values.filter(v => this._getValue(v) < this._level).length;
            //if (this._options.isolateUnchanged)
            //c -= d.values.filter(v => v.growth === 0).length;

            if (c > a) {
              a = c;
              da = d;
            }

            if (c < b) {
              b = c;
              db = d;
            }
          });

          this._shift = {
            min: { offset: b, data: db },
            max: { offset: a, data: da }
          };
        }

        _calcLeftMargin() {
          const max = this._calcTextLength("-999");
          const margin = this._options.showSlider ? 40 + this._charBox.height : 0; // slider + value text height
          this._leftMargin = margin + max + 6; // max rank tick width + tick line
        }

        _calcConstants() {
          this._calcDotRadius();
          this._calcMaxY();
        }

        _calcDotRadius() {
          const availHeight = this._height - this._innerMargin - this._legendHeight;

          let n = this._keys.length * 2;
          if (this._maxUnchangedCount > 0) n += this._maxUnchangedCount + 2;

          const r1 = availHeight / n / 2,
            r2 = (this._width - this._leftMargin) / this._chartData.length / 2;

          if (r1 < r2) this._dotRadius = r1;
          else {
            // radius is based on width and data.length. adjust to fit the available height
            let total = n * r2;
            if (r2 > availHeight) this._dotRadius = r2 - (total - availHeight) / 2;
            else this._dotRadius = r2;
          }
          this._dotDiameter = this._dotRadius * 2;
        }

        _calcMaxY() {
          var dots = this._shift.max.offset + this._keys.length;
          if (this._options.isolateUnchanged && this._maxUnchangedCount > 0)
            dots += this._maxUnchangedCount + 2;
          this._maxY = dots * this._dotDiameter;
        }

        _initScales() {
          this._x = d3
            .scalePoint()
            .domain(this._seq(0, this._chartData.length))
            .range([0, this._width - this._leftMargin]);
          this._y = n => n * this._dotDiameter;

          this._cp = d3
            .scaleSequential(this._options.posPalette)
            .domain([this._pMin, this._pMax])
            .nice()
            .clamp(true);
          this._cn = d3
            .scaleSequential(this._options.negPalette)
            .domain([this._nMax, this._nMin])
            .nice()
            .clamp(true);

          this._initRankScale();
          this._initUnchangedScale();
        }

        _initRankScale() {
          /*
               * // Buggy dynamic scale
              var
                  a = this._rMax, b = this._rMin,
                  s = 0, l = 0;
      
              // the rank is never going to be zero:
              // 1 ~ n for pos
              // -1 ~ -n for neg
              // the series only contains postive ranks
              if (a > 0 && b > 0) {
                  s = 0;
                  l = a - b + 1;
              }
              // the series only contains negative ranks
              else if (a < 0 && b < 0) {
                  s = b;
                  l = Math.abs(b) - Math.abs(a) + 1;
              }
              // from positive to negative
              else {
                  s = b;
                  l = a - b;
              }        
              
              // Max offset should always equal to |_rMin|
              // This check avoids the difference caused by unchanged dots
              var sm = this._shift.max.offset;
              if (this._options.isolateUnchanged && sm != Math.abs(this._rMin)) sm = Math.abs(this._rMin);
      
              this._rk = d3.scalePoint()
                  .domain(this._seq(s, l).reverse())
                  .range([this._y(this._shift.min.offset), this._y(sm + this._keys.length)]);
              */

          const len = this._keys.length;
          this._rk = d3
            .scalePoint()
            .domain(this._seq(-len, len * 2 + 1).reverse())
            .range([this._y(0), this._y(len * 2)]);
        }

        _initUnchangedScale() {
          const maxDataLen = this._shift.max.data ? this._keys.length : 0;
          var bottom = 0;
          if (this._shift.max.offset === 0)
            bottom = (this._keys.length + 2) * this._dotDiameter;
          else
            bottom =
              this._y(this._shift.max.offset) + (maxDataLen + 2) * this._dotDiameter;

          this._yu = d3
            .scalePoint()
            .domain(this._seq(0, this._maxUnchangedCount))
            .range([
              bottom + (this._maxUnchangedCount - 1) * this._dotDiameter,
              bottom
            ]);
        }

        _render() {
          if (this._options.debug) {
            //Boundry for debugging
            this._container
              .append("rect")
              .attr("width", this._width)
              .attr("height", this._height)
              .attr("stroke-width", 0.1)
              .attr("fill", "none")
              .attr("stroke", "black");
          }

          this._renderGroups();
          this._renderDots();
          this._renderRankAxis();
          this._renderUnchangedLabel();
          this._renderXAxis();
          this._renderLegend();
          if (this._options.showSlider) this._renderSlider();
        }

        _renderGroups() {
          const that = this;

          this._container.on("click.eric.trendchart." + this._uniqueId, () => {
            if (this._options.clickAction === "none") return;
            this._focusedKey = this._focusedRange = null;
            this._cancel();
            this._cancelRange();
          });

          // Container group
          // Contains main chart group, slider group and legend group
          this._cg = this._container
            .append("g")
            .attr("font-family", this._options.fontFamily)
            .attr("font-size", this._options.fontSize);

          // Main chart group
          this._g = this._cg
            .append("g")
            .attr(
              "transform",
              `translate(${this._leftMargin - this._dotRadius},${this._legendHeight})`
            )
            .on("mouseleave", (e, d) => {
              this._highlighter.attr("opacity", 0);
            });

          // Period groups
          this._og = this._g
            .selectAll("g")
            .data(this._chartData)
            .enter()
            .append("g")
            .attr(
              "transform",
              (d, i) => `translate(${this._x(i)},${this._innerMargin})`
            )
            .on("mouseenter", function (e, d) {
              const i = that._og.nodes().indexOf(this);
              that._highlighter.attr("opacity", (_, j) => (i === j ? 1 : 0));
            });

          this._highlighter = this._og
            .append("rect")
            .attr("class", "highlighter")
            .attr("opacity", 0)
            .attr("fill", this._color.highlighter)
            .attr("rx", 4)
            .attr("ry", 4)
            .attr("x", -this._dotRadius)
            .attr("y", -this._dotRadius)
            .attr("width", this._dotRadius * 2)
            .attr("height", this._maxY);

          this._ig = this._og.append("g").attr("class", "ig");
          this._shiftColumn(this._ig);
        }

        _shiftColumn(selection, transition) {
          const s = transition
            ? selection
              .transition()
              .ease(d3.easeElastic)
              .duration(1000)
            : selection;

          s.attr("transform", d => {
            var unchanged = 0,
              under = 0;
            if (this._options.isolateUnchanged) {
              for (var i = 0; i < d.values.length; i++) {
                const n = this._getValue(d.values[i]),
                  g = this._isNumber ? d.values[i].growth : n;
                if (g === 0) unchanged++;
                else if (n < this._level) under++;
              }
            } else {
              under = d.values.filter(v => this._getValue(v) <= this._level).length;
            }
            return `translate(0,${this._y(under + unchanged)})`;
          });
        }

        _updateDots() {
          this._og.data(this._chartData);
          this._shiftColumn(this._og.select(".ig"), true);
          this._renderDots(true);
        }

        _renderDots(transition) {
          const options = this._options,
            level = this._level;

          // Positive dots
          this._renderSection(
            this._ig,
            "pos",
            v => {
              const n = this._getValue(v),
                g = this._isNumber ? v.growth : n;
              return options.isolateUnchanged ? g !== 0 && n >= level : n >= level;
            },
            this._y,
            this._cp,
            transition
          );

          // Negative dots
          this._renderSection(
            this._ig,
            "neg",
            v => {
              const n = this._getValue(v),
                g = this._isNumber ? v.growth : n;
              return options.isolateUnchanged ? g !== 0 && n < level : n < level;
            },
            this._y,
            this._cn,
            transition
          );

          // Unchanged dots
          if (options.isolateUnchanged) {
            this._renderSection(
              this._og,
              "zero",
              v => v.growth === 0,
              this._yu,
              this._color.unchanged,
              transition
            );
          }

          this._dots = this._og.selectAll(".pos,.neg");
        }

        _renderSection(g, className, filter, y, color, transition) {
          let shape = "circle";
          if (this._options.shape === "square") shape = "rect";
          return g
            .selectAll("." + className)
            .data(d => d.values.filter(filter))
            .join(
              enter =>
                this._drawShape(
                  this._attachEvents(
                    this._updateShape(
                      enter.append("g").attr("class", className),
                      y,
                      color
                    )
                  ).append(shape),
                  transition
                ),
              update => this._updateShape(update, y, color),
              exit => exit.remove()
            );
        }

        _updateShape(selection, y, c) {
          if (typeof c === "function")
            selection.attr("fill", d => c(this._getValue(d)));
          else selection.attr("fill", c);

          if (this._isCircle)
            selection.attr("transform", (d, i) => `translate(0,${y(d.pos || i)})`);
          else
            selection.attr(
              "transform",
              (d, i) => `translate(0,${y(d.pos || i) - this._dotRadius})`
            );
          return selection;
        }

        _drawShape(selection, transition) {
          if (this._isCircle)
            (transition
              ? selection
                .attr("r", 0)
                .transition()
                .duration(500)
              : selection
            ).attr("r", this._dotRadius);
          else {
            selection
              .attr("width", this._dotDiameter)
              .attr("height", 0)
              .attr("x", -this._dotRadius)
              .attr("rx", 4)
              .attr("ry", 4);
            (transition ? selection.transition().duration(500) : selection).attr(
              "height",
              this._dotDiameter
            );
          }
          return selection;
        }

        _attachEvents(selection) {
          selection
            .on("mouseenter", (e, d) => {
              if (!this._focusedKey) this._highlight(d);
              this._showTooltip(e, d);
              if (this._onhover) this._onhover(d);
            })
            .on("mouseleave", (e, d) => {
              if (!this._focusedKey) this._cancel(d);
              this._hideTooltip();
            })
            .on("click", (e, d) => {
              if (this._options.clickAction === "none") return;

              if (this._focusedKey === d) {
                this._focusedKey = null;
                this._cancel();
                if (this._oncancel) this._oncancel(d);
              } else {
                this._focusedKey = d;
                this._cancel();
                this._highlight(d);
                if (this._onclick) this._onclick(d);
              }
              e.stopPropagation();
            });
          return selection;
        }

        _highlight(d) {
          const hc = this._og
            .selectAll("g")
            .filter(_ => _ && _.key === d.key)
            .append("circle")
            .attr("class", "hc")
            .attr("stroke", "white")
            .attr("fill", "black");
          if (!this._isCircle) hc.attr("cy", this._dotRadius);

          hc.transition()
            .duration(250)
            .attr("r", this._dotRadius / 2);
        }

        _cancel() {
          this._og.selectAll(".hc").remove();
        }

        _showTooltip(e, d) {
          const info = [
            d.tick,
            d.key,
            `IOS_income: ${d.number}`,
            `Growth: ${d.index === 0 ? "-" : d.growth || "-"}`,
            "Growth Rate: " +
            (d.index !== 0 && d.rate ? `${(d.rate * 100).toFixed(2)}%` : "-")
          ];

          var max = 0;
          info.forEach(s => {
            const l = this._calcTextLength(s);
            if (l > max) max = l;
          });

          if (!this._infoBox)
            this._infoBox = this._g
              .append("g")
              .attr("fill", this._tooltip.color)
              .call(g =>
                g
                  .append("rect")
                  .attr("class", "ibbg")
                  .attr("opacity", this._tooltip.boxOpacity)
                  .attr("stroke", "#aaa")
                  .attr("stroke-width", 0.5)
                  .attr("rx", 4)
                  .attr("ry", 4)
                  .attr("x", -5)
                  .attr("y", -5)
                  .attr("fill", this._tooltip.boxColor)
              );

          const spacing = 1.1;
          this._infoBox
            .style("visibility", "visible")
            .select(".ibbg")
            .attr("width", max + 15)
            .attr("height", spacing * this._charBox.height * info.length + 5);

          this._infoBox
            .selectAll("text")
            .data(info)
            .join(
              enter =>
                enter
                  .append("text")
                  .attr("dy", (d, i) => `${spacing * i + 1}em`)
                  .text(d => d),
              update => update.text(d => d),
              exit => exit.remove()
            );

          const svg = this._getSVG();
          if (svg) {
            // convert to SVG coordinates
            const p = svg.createSVGPoint(),
              box = this._infoBox.node().getBBox(),
              gr = this._g.node().getBoundingClientRect(),
              dr = e.currentTarget.getBoundingClientRect();
            p.x = dr.left + dr.width + this._dotRadius;
            p.y = dr.top + dr.width + this._dotRadius;
            const converted = p.matrixTransform(
              this._g
                .node()
                .getScreenCTM()
                .inverse()
            );

            const left =
              converted.x + box.width + gr.left + this._dotRadius > this._width
                ? converted.x - box.width - this._dotDiameter
                : converted.x,
              top =
                converted.y + box.height + gr.top + this._dotRadius > this._height
                  ? converted.y - box.height - this._dotDiameter
                  : converted.y;

            this._infoBox.attr("transform", `translate(${left},${top})`);
          }
        }

        _getSVG() {
          let curr = this._container.node();
          while (curr && curr.tagName !== "svg") curr = curr.parentElement;
          return curr;
        }

        _hideTooltip(d) {
          if (this._infoBox) this._infoBox.style("visibility", "hidden");
        }

        _renderRankAxis() {
          const ticks = d3
            .axisLeft(this._rk)
            .tickValues(this._rk.domain().filter(d => d % 3 === 0));

          if (this._rankAxis) this._rankAxis.remove();

          this._rankAxis = this._g
            .append("g")
            .attr(
              "transform",
              `translate(${-this._dotRadius}, ${this._innerMargin - this._dotRadius})`
            )
            .call(ticks)
            .call(g => {
              g.attr("font-family", this._options.font).attr(
                "font-size",
                this._tick.fontSize
              );
              g.select(".domain").remove();
              g.selectAll(".tick")
                .select("line")
                .attr("stroke", this._tick.color);
              g.selectAll(".tick text").attr("fill", this._tick.color);
            });

          const y = this._rk(0) + this._innerMargin - this._dotRadius;
          if (y && !this._zeroLine) {
            this._zeroLine = this._g
              .append("line")
              .attr("stroke-width", 0.5)
              .attr("stroke", this._tick.color)
              .attr("stroke-dasharray", "3")
              .attr("x1", -this._dotRadius)
              .attr("x2", this._x.range()[1] + this._dotRadius);
          }
          if (this._zeroLine) this._zeroLine.attr("y1", y).attr("y2", y);
        }

        _renderUnchangedLabel() {
          if (this._options.isolateUnchanged && this._maxUnchangedCount > 0) {
            if (!this._uncLabel)
              this._uncLabel = this._g
                .append("text")
                .attr("fill", this._tick.color)
                .text("Unchanged");

            const ty = this._maxY + this._innerMargin;
            if (ty + this._legendHeight + this._charBox.height > this._height)
              this._uncLabel
                .attr("dy", "-0.5em")
                .attr("text-anchor", "end")
                .attr(
                  "transform",
                  `translate(${-this._dotRadius},${ty - this._dotRadius})`
                );
            else
              this._uncLabel
                .attr("dy", "0.25em")
                .attr("text-anchor", "start")
                .attr("transform", `translate(${-this._dotRadius},${ty})`);
          }
        }

        _processLegend() {
          const that = this,
            ticks = [],
            ts = this._cn
              .ticks()
              .concat(this._cp.ticks())
              .sort((a, b) => a - b);
          for (let i = 0; i < ts.length - 1; i += 3) addTick(i);
          const last = ts[ts.length - 1];
          if (ticks[ticks.length - 1].floor != last && last <= this._pMax)
            addTick(ts.length - 1);

          let legendWidth = 0;
          ticks.forEach(d => {
            let len = this._calcTextLength(d.label);
            if (len > legendWidth) legendWidth = len;
          });
          legendWidth += 10;

          return { ticks, legendWidth };

          function addTick(i) {
            const floor = ts[i];
            ticks.push({
              floor: floor,
              ceiling: i + 3 < ts.length ? ts[i + 3] : Number.POSITIVE_INFINITY,
              color: floor < that._level ? that._cn(floor) : that._cp(floor),
              label: formatLabel(floor)
            });
          }

          function formatLabel(n) {
            return that._isRate ? d3.format(".1f")(n * 100) : d3.format(".2s")(n);
          }
        }

        _renderLegend() {
          const that = this,
            { ticks, legendWidth } = this._processLegend();

          if (!this._legendBox) this._legendBox = this._cg.append("g");

          this._legendBox
            .attr(
              "transform",
              `translate(${this._width - ticks.length * legendWidth},0)`
            )
            .selectAll("g")
            .data(ticks)
            .join(
              enter => {
                const g = enter
                  .append("g")
                  .attr("transform", (d, i) => `translate(${i * legendWidth},0)`)
                  .call(g =>
                    g
                      .append("line")
                      .attr("x1", 0.5)
                      .attr("x2", 0.5)
                      .attr("y1", "1em")
                      .attr("y2", "1.3em")
                      .attr("stroke-width", 0.5)
                      .attr("stroke", this._color.legend)
                  )
                  .on("mouseenter", (e, d) => {
                    if (!this._focusedRange) this._highlightRange(d);
                  })
                  .on("mouseleave", () => {
                    if (!this._focusedRange) this._cancelRange();
                  })
                  .on("click", (e, d) => {
                    if (this._options.clickAction === "none") return;

                    if (this._focusedRange === d) {
                      this._focusedRange = null;
                      this._cancelRange();
                    } else {
                      this._focusedRange = d;
                      this._cancelRange();
                      this._highlightRange(d);
                    }
                    e.stopPropagation();
                  });

                updateLegend(
                  g
                    .append("rect")
                    .attr("width", legendWidth)
                    .attr("height", "1em"),
                  g
                    .append("text")
                    .attr("fill", this._color.legend)
                    .attr("dy", "2.2em")
                );
              },
              update => updateLegend(update.select("rect"), update.select("text")),
              exit => exit.remove()
            );

          function updateLegend(rect, text) {
            rect.attr("fill", d => d.color);
            text.text((d, i) => {
              const last = i === ticks.length - 1;
              return (last ? ">" : "") + d.label + (last && that._isRate ? "%" : "");
            });
          }
        }

        _highlightRange(d) {
          this._dots.attr("opacity", _ => {
            const n = this._getValue(_);
            return n >= d.floor && n < d.ceiling ? 1 : 0.3;
          });
        }

        _cancelRange() {
          this._dots.attr("opacity", 1);
        }

        _renderSlider() {
          const that = this,
            height = this._keys.length * 2 * this._dotDiameter,
            top = this._legendHeight + this._innerMargin - this._dotRadius;

          var inputGroup = this._cg.append("g");
          // Doesn't work in Safari
          //.attr("transform", `translate(0,${top})`);

          const label = inputGroup
            .append("text")
            .attr("y", 0)
            .attr("fill", this._tick.color)
            .attr("text-anchor", "middle")
            .text(this._level);

          const vbox = label.node().getBBox();
          label
            .attr("x", vbox.height)
            .attr("transform", `rotate(270,${vbox.height},0)`)
            .text("");

          const min = this._nMin > 0 ? this._nMin / 1.01 : this._nMin * 1.01,
            max = this._pMax * 1.01,
            step = Math.abs(min) / 100;

          const fo = inputGroup
            .append("foreignObject")
            .attr("x", this._charBox.height)
            .attr("y", top)
            .attr("width", 20)
            .attr("height", height + 2);

          const slider = fo
            .append("xhtml:input")
            .attr("type", "range")
            .attr("min", min)
            .attr("max", max)
            .attr("step", step)
            .style("width", `${height}px`)
            .style("height", "20px")
            .style("transform-origin", "10px 10px")
            .style("transform", "rotate(90deg)")
            .on("click", e => e.stopPropagation())
            .on("dblclick", e => {
              slider.node().value = this._defaultLevel;
              change();
              e.stopPropagation();
            })
            .on("input", () => change());

          // This fixes a weird behavior if both min and max are floating poing numbers
          slider.node().value = this._level;

          function change() {
            var tw = label.node().getBBox().width,
              hw = tw / 2;

            var v = parseFloat(slider.node().value);
            var p = Math.abs(max - v);
            var ty = height - (p / (max - min)) * height + top;

            if (ty + hw - top > height) ty = height - hw + top;
            else if (ty - hw - top <= 0) ty = hw + top;

            var vtext = "Number < ";
            if (that._isGrowth) vtext = "Growth < ";
            else if (that._isRate) vtext = "Growth Rate < ";
            const dv = that._isRate ? v * 100 : v;
            vtext += !that._isRate
              ? dv.toFixed(0)
              : dv.toFixed(2) + (that._isRate ? "%" : "");

            label
              .attr("y", ty)
              .attr("transform", `rotate(270,${vbox.height},${ty})`)
              .text(vtext);
            that._level = v;
            that._changeLevel();
          }
        }

        _changeLevel() {
          this._pMin = 0;
          this._pMax = 0;
          this._nMin = 0;
          this._nMax = 0;
          this._rMin = 0;
          this._rMax = 0;

          this._process(true);
          this._calcShift();
          this._calcMaxY();
          this._initScales();

          this._updateDots();
          //this._renderRankAxis();
          this._renderUnchangedLabel();
          this._renderLegend();
          this._highlighter.attr("height", this._maxY);

          if (this._focusedKey) {
            this._cancel();
            this._highlight(this._focusedKey);
          }
          if (this._focusedRange) {
            this._cancelRange();
            this._highlightRange(this._focusedRange);
          }
        }

        _renderXAxis() {
          var max = 0;
          const range = this._x.range(),
            scale = d3
              .scalePoint()
              .domain(
                this._chartData.map(d => {
                  const len = this._calcTextLength(d.tick);
                  if (len > max) max = len;
                  return d.tick;
                })
              )
              .range(range);

          var intr;
          if (this._tick.interval === "auto") {
            const c = Math.floor((range[1] - range[0]) / max / 2);
            intr = Math.ceil(this._chartData.length / c);
          } else intr = +this._tick.interval;

          var ticks = d3
            .axisTop(scale)
            .tickValues(scale.domain().filter((d, i) => i % intr === 0));

          const ex = this._tick.extractor;
          this._g
            .append("g")
            .attr("fill", this._tick.color)
            .selectAll("g")
            .data(ticks.tickValues())
            .enter()
            .append("g")
            .attr("transform", d => `translate(${scale(d) - this._dotRadius},0)`)
            .call(g => {
              g.append("text")
                .attr("dy", "1em")
                .attr("dx", 3)
                .text(d => (ex && typeof ex === "function" ? ex(d) : d));
            })
            .call(g => {
              g.append("line")
                .attr("stroke-width", 0.5)
                .attr("stroke", this._tick.color)
                .attr("stroke-dasharray", "3")
                .attr("y1", 0)
                .attr("y2", this._maxY);
            });
        }

        _getValue(d) {
          return this._isNumber ? d.number : this._isGrowth ? d.growth : d.rate;
        }

        _getCharBox() {
          this._charBox = this._textBox
            .text("M")
            .node()
            .getBBox();
        }

        _calcTextLength(text) {
          return this._textBox
            .text(text)
            .node()
            .getBBox().width;
        }

        _seq(start, length) {
          const a = new Array(length);
          for (let i = 0; i < length; i++) a[i] = i + start;
          return a;
        }
      }
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`## Functions & Parameters`
    )
  });
  main.variable(observer("color")).define("color", ["d3", "region_wise"], function (d3, region_wise) {
    return (
      d3.scaleOrdinal(
        d3.quantize(d3.interpolateRainbow, region_wise.children.length + 1)
      )
    )
  });
  main.variable(observer("format")).define("format", ["d3"], function (d3) {
    return (
      d3.format("$,.0f")
    )
  });
  main.variable(observer("formatTime")).define("formatTime", function () {
    return (
      seconds => {
        const isNegative = seconds < 0;
        const sign = isNegative ? '-' : '';

        const s = Math.floor(Math.abs(seconds));

        const m = Math.floor(s / 60);
        const ss = s - m * 60;

        const h = Math.floor(m / 60);
        const mm = m - h * 60;

        if (h === 0) {
          return `${sign}${mm}:${String(ss).padStart(2, 0)}`;
        } else {
          return `${sign}${h}:${String(mm).padStart(2, 0)}:${String(ss).padStart(
            2,
            0
          )}`;
        }
      }
    )
  });
  main.variable(observer("getPalettes")).define("getPalettes", ["d3"], function (d3) {
    return (
      scheme => {
        let pp, np;
        if (scheme === "rdylbu") {
          pp = d3.interpolateYlGnBu;
          np = d3.interpolateYlOrRd;
        }
        else if (scheme === "rdylgn") {
          pp = d3.interpolateYlGn;
          np = d3.interpolateYlOrRd;
        }
        else if (scheme === "rdpubu") {
          pp = d3.interpolatePuBu;
          np = d3.interpolatePuRd;
        }
        else if (scheme === "rdgn") {
          pp = d3.interpolateGreens;
          np = d3.interpolateReds;
        }
        else if (scheme === "orbu") {
          pp = d3.interpolateBlues;
          np = d3.interpolateOranges;
        }
        return { pp, np };
      }
    )
  });
  main.variable(observer("partition")).define("partition", ["d3", "height_2", "width"], function (d3, height_2, width) {
    return (
      data => {
        const root = d3.hierarchy(data)
          .sum(d => d.value)
          .sort((a, b) => b.height - a.height || b.value - a.value);
        return d3.partition()
          .size([height_2, (root.height + 1) * width / 3])
          (root);
      }
    )
  });
  main.variable(observer("miniChart")).define("miniChart", ["ios_income", "d3", "options"], function (ios_income, d3, options) {
    return (
      (svg, x, y, width, height) => {
        const columns = ios_income.columns.slice(1);
        const sx = d3
          .scaleBand()
          .domain(columns)
          .range([0, width]);
        const sy = d3
          .scaleLinear()
          .domain(d3.extent(columns.map(c => ios_income[0][c])))
          .nice()
          .range([height, 0]);
        const bandwidth = { half: sx.bandwidth() / 2, qtr: sx.bandwidth() / 4 };

        const chart = svg.append("g").attr("transform", `translate(${x},${y})`);
        const caption = chart
          .append("text")
          .attr("text-anchor", "middle")
          .attr("font-weight", "bold")
          .attr("transform", `translate(${width / 2},${height + 35})`);

        chart
          .append("g")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(sx));
        var axisY = chart.append("g").call(
          d3
            .axisLeft(sy)
            .ticks(2, "s")
            .tickValues(sy.domain())
        );

        update({ co: { name: "Total" }, getRow: () => ios_income[0] });

        function update(context) {
          axisY.remove();

          const rdata = context.getRow();
          const s =
            options.dataset === "china" ? "Mobile Games in China" : options.field;
          const values = columns.map(c => rdata[c]);
          sy.domain(d3.extent(values)).nice();
          axisY = chart.append("g").call(
            d3
              .axisLeft(sy)
              .ticks(2, "s")
              .tickValues(sy.domain())
          );

          chart
            .selectAll("rect")
            .data(values)
            .join("rect")
            .attr("fill", "#a8dadc")
            .call(g => {
              g.select("title").remove();
              g.append("title").text(d => d3.format(",d")(d));
            })
            .attr("x", (d, i) => sx(columns[i]) + bandwidth.qtr)
            .attr("y", d => sy(d))
            .attr("width", bandwidth.half)
            .attr("height", d => height - sy(d));
        }

        return update;
      }
    )
  });
  main.variable(observer("miniChart2")).define("miniChart2", ["ios_download", "d3", "options"], function (ios_download, d3, options) {
    return (
      (svg, x, y, width, height) => {
        const columns = ios_download.columns.slice(1);
        const sx = d3.scaleBand().domain(columns).range([0, width]);
        const sy = d3.scaleLinear()
          .domain(d3.extent(columns.map(c => ios_download[0][c]))).nice()
          .range([height, 0]);
        const bandwidth = { half: sx.bandwidth() / 2, qtr: sx.bandwidth() / 4 };

        const chart = svg.append("g").attr("transform", `translate(${x},${y})`);
        const caption = chart.append("text")
          .attr("text-anchor", "middle")
          .attr("font-weight", "bold")
          .attr("transform", `translate(${width / 2},${height + 35})`);

        chart.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(sx));
        var axisY = chart.append("g").call(d3.axisLeft(sy).ticks(2, "s").tickValues(sy.domain()));

        update({ co: { name: "Total" }, getRow: () => ios_download[0] });

        function update(context) {
          axisY.remove();

          const rdata = context.getRow();
          const s = options.dataset === "china" ? "Mobile Game in China" : options.field;
          const values = columns.map(c => rdata[c]);
          sy.domain(d3.extent(values)).nice();
          axisY = chart.append("g").call(d3.axisLeft(sy).ticks(2, "s").tickValues(sy.domain()));

          chart.selectAll("rect")
            .data(values)
            .join("rect")
            .attr("fill", "#a8dadc")
            .call(g => {
              g.select("title").remove();
              g.append("title").text(d => d3.format(",d")(d));
            })
            .attr("x", (d, i) => sx(columns[i]) + bandwidth.qtr)
            .attr("y", d => sy(d))
            .attr("width", bandwidth.half)
            .attr("height", d => height - sy(d));
        }

        return update;
      }
    )
  });
  main.variable(observer("videoControls1")).define("videoControls1", ["html", "formatTime"], function (html, formatTime) {
    return (
      function videoControls1(mediaElement, { secondaryMediaElements = [] } = {}) {
        // --- Options
        const sliderWidth = 180;
        const sliderStep = 0.01; // in seconds

        // --- DOM

        // Control
        const control = html`<form style="font: 12px var(--sans-serif); font-variant-numeric: tabular-nums; display: flex; height: 33px; align-items: center;">`;

        // Button
        const buttonName = 'play';
        const button = html`<button name=${buttonName} type=button style="margin-right: 0.4em; width: 5em;"></button>`;
        control.appendChild(button);

        // Slider and output
        const sliderInput = html`<input name=i type=range min=0 max=${mediaElement.duration} value=${mediaElement.currentTime} step=${sliderStep} style="width: ${sliderWidth}px;">`;
        const sliderOutput = html`<output name=o style="margin-left: 0.4em;">`;
        const sliderLabel = html`<label style="display: flex; align-items: center;">`;
        sliderLabel.appendChild(sliderInput);
        sliderLabel.appendChild(sliderOutput);
        control.appendChild(sliderLabel);

        // --- State
        // the state is managed by mediaElement (the video)

        Object.defineProperty(control, 'value', {
          enumerable: true,
          configurable: false,
          get: () => mediaElement.currentTime,
          set: value => {
            mediaElement.pause();
            mediaElement.currentTime = value;
            onTimeUpdate();
          }
        });

        // --- Callback functions
        function onPlayPause() {
          control.play.innerText = mediaElement.paused ? 'Play' : 'Pause';
        }

        function synchronizeTime() {
          const t = mediaElement.currentTime;
          secondaryMediaElements.forEach(d => {
            d.mediaElement.currentTime = t + d.timeOffset;
          });
        }

        function onTimeUpdate() {
          const t = mediaElement.currentTime;
          if (mediaElement.paused) {
            synchronizeTime();
          }
          control.i.valueAsNumber = t;
          sliderOutput.value = `${formatTime(t)} / ${formatTime(control.i.max)}`;
          control.dispatchEvent(new CustomEvent("input", { bubbles: true }));
        }

        function onDurationChange() {
          control.i.max = "" + mediaElement.duration;
          onTimeUpdate();
        }

        function onPlayButton() {
          if (mediaElement.paused) {
            synchronizeTime();
            mediaElement.play();
            secondaryMediaElements.map(d => d.mediaElement.play());
          } else {
            mediaElement.pause();
            secondaryMediaElements.map(d => d.mediaElement.pause());
          }
          onPlayPause();
        }

        function onSliderChange() {
          mediaElement.currentTime = control.i.valueAsNumber;
        }

        // --- Events
        mediaElement.addEventListener('timeupdate', onTimeUpdate);
        mediaElement.addEventListener('durationchange', onDurationChange);
        mediaElement.addEventListener('pause', onPlayPause);
        mediaElement.addEventListener('play', onPlayPause);
        control.play.addEventListener('click', onPlayButton);
        control.i.addEventListener('input', onSliderChange);

        // --- Init
        onPlayPause();
        onDurationChange();

        // --- Clean
        control.dispose = () => {
          mediaElement.removeEventListener('timeupdate', onTimeUpdate);
          mediaElement.removeEventListener('durationchange', onDurationChange);
          mediaElement.removeEventListener('pause', onPlayPause);
          mediaElement.removeEventListener('play', onPlayPause);
          control.play.removeEventListener('click', onPlayButton);
          control.i.removeEventListener('input', onSliderChange);
        };

        return control;
      }
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`## Parameters`
    )
  });
  main.variable(observer("height")).define("height", ["screen"], function (screen) {
    return (
      screen.height * 0.6
    )
  });
  main.variable(observer("height_2")).define("height_2", function () {
    return (
      1200
    )
  });
  main.variable(observer("width_2")).define("width_2", function () {
    return (
      975
    )
  });
  main.variable(observer()).define(["md"], function (md) {
    return (
      md`## Appendix`
    )
  });
  main.variable(observer("embed")).define("embed", ["require"], function (require) {
    return (
      require.alias({
        "vega": "vega@5.20.0",
        "vega-lite": "vega-lite@5.0.0"
      })("vega-embed@6")
    )
  });
  main.variable(observer("d3")).define("d3", ["require"], function (require) {
    return (
      require("d3@6", "d3-sankey@0.12")
    )
  });
  const child1 = runtime.module(define1);
  main.import("form", child1);
  const child2 = runtime.module(define2);
  main.import("src", child2);
  main.import("getStatesLastNDays", child2);
  const child3 = runtime.module(define3);
  main.import("videoControls", child3);
  return main;
}
